// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Markets.proto

#ifndef PROTOBUF_Markets_2eproto__INCLUDED
#define PROTOBUF_Markets_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace OTDB {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Markets_2eproto();
void protobuf_AssignDesc_Markets_2eproto();
void protobuf_ShutdownFile_Markets_2eproto();

class MarketData_InternalPB;
class MarketList_InternalPB;
class OfferDataMarket_InternalPB;
class OfferListMarket_InternalPB;
class TradeDataMarket_InternalPB;
class TradeListMarket_InternalPB;
class OfferDataNym_InternalPB;
class OfferListNym_InternalPB;
class TradeDataNym_InternalPB;
class TradeListNym_InternalPB;

// ===================================================================

class MarketData_InternalPB : public ::google::protobuf::Message {
 public:
  MarketData_InternalPB();
  virtual ~MarketData_InternalPB();

  MarketData_InternalPB(const MarketData_InternalPB& from);

  inline MarketData_InternalPB& operator=(const MarketData_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketData_InternalPB& default_instance();

  void Swap(MarketData_InternalPB* other);

  // implements Message ----------------------------------------------

  MarketData_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketData_InternalPB& from);
  void MergeFrom(const MarketData_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline const ::std::string& server_id() const;
  inline void set_server_id(const ::std::string& value);
  inline void set_server_id(const char* value);
  inline void set_server_id(const char* value, size_t size);
  inline ::std::string* mutable_server_id();
  inline ::std::string* release_server_id();
  inline void set_allocated_server_id(::std::string* server_id);

  // optional string market_id = 3;
  inline bool has_market_id() const;
  inline void clear_market_id();
  static const int kMarketIdFieldNumber = 3;
  inline const ::std::string& market_id() const;
  inline void set_market_id(const ::std::string& value);
  inline void set_market_id(const char* value);
  inline void set_market_id(const char* value, size_t size);
  inline ::std::string* mutable_market_id();
  inline ::std::string* release_market_id();
  inline void set_allocated_market_id(::std::string* market_id);

  // optional string asset_type_id = 4;
  inline bool has_asset_type_id() const;
  inline void clear_asset_type_id();
  static const int kAssetTypeIdFieldNumber = 4;
  inline const ::std::string& asset_type_id() const;
  inline void set_asset_type_id(const ::std::string& value);
  inline void set_asset_type_id(const char* value);
  inline void set_asset_type_id(const char* value, size_t size);
  inline ::std::string* mutable_asset_type_id();
  inline ::std::string* release_asset_type_id();
  inline void set_allocated_asset_type_id(::std::string* asset_type_id);

  // optional string currency_type_id = 5;
  inline bool has_currency_type_id() const;
  inline void clear_currency_type_id();
  static const int kCurrencyTypeIdFieldNumber = 5;
  inline const ::std::string& currency_type_id() const;
  inline void set_currency_type_id(const ::std::string& value);
  inline void set_currency_type_id(const char* value);
  inline void set_currency_type_id(const char* value, size_t size);
  inline ::std::string* mutable_currency_type_id();
  inline ::std::string* release_currency_type_id();
  inline void set_allocated_currency_type_id(::std::string* currency_type_id);

  // optional string scale = 6;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 6;
  inline const ::std::string& scale() const;
  inline void set_scale(const ::std::string& value);
  inline void set_scale(const char* value);
  inline void set_scale(const char* value, size_t size);
  inline ::std::string* mutable_scale();
  inline ::std::string* release_scale();
  inline void set_allocated_scale(::std::string* scale);

  // optional string total_assets = 7;
  inline bool has_total_assets() const;
  inline void clear_total_assets();
  static const int kTotalAssetsFieldNumber = 7;
  inline const ::std::string& total_assets() const;
  inline void set_total_assets(const ::std::string& value);
  inline void set_total_assets(const char* value);
  inline void set_total_assets(const char* value, size_t size);
  inline ::std::string* mutable_total_assets();
  inline ::std::string* release_total_assets();
  inline void set_allocated_total_assets(::std::string* total_assets);

  // optional string number_bids = 8;
  inline bool has_number_bids() const;
  inline void clear_number_bids();
  static const int kNumberBidsFieldNumber = 8;
  inline const ::std::string& number_bids() const;
  inline void set_number_bids(const ::std::string& value);
  inline void set_number_bids(const char* value);
  inline void set_number_bids(const char* value, size_t size);
  inline ::std::string* mutable_number_bids();
  inline ::std::string* release_number_bids();
  inline void set_allocated_number_bids(::std::string* number_bids);

  // optional string number_asks = 9;
  inline bool has_number_asks() const;
  inline void clear_number_asks();
  static const int kNumberAsksFieldNumber = 9;
  inline const ::std::string& number_asks() const;
  inline void set_number_asks(const ::std::string& value);
  inline void set_number_asks(const char* value);
  inline void set_number_asks(const char* value, size_t size);
  inline ::std::string* mutable_number_asks();
  inline ::std::string* release_number_asks();
  inline void set_allocated_number_asks(::std::string* number_asks);

  // optional string last_sale_price = 10;
  inline bool has_last_sale_price() const;
  inline void clear_last_sale_price();
  static const int kLastSalePriceFieldNumber = 10;
  inline const ::std::string& last_sale_price() const;
  inline void set_last_sale_price(const ::std::string& value);
  inline void set_last_sale_price(const char* value);
  inline void set_last_sale_price(const char* value, size_t size);
  inline ::std::string* mutable_last_sale_price();
  inline ::std::string* release_last_sale_price();
  inline void set_allocated_last_sale_price(::std::string* last_sale_price);

  // optional string current_bid = 11;
  inline bool has_current_bid() const;
  inline void clear_current_bid();
  static const int kCurrentBidFieldNumber = 11;
  inline const ::std::string& current_bid() const;
  inline void set_current_bid(const ::std::string& value);
  inline void set_current_bid(const char* value);
  inline void set_current_bid(const char* value, size_t size);
  inline ::std::string* mutable_current_bid();
  inline ::std::string* release_current_bid();
  inline void set_allocated_current_bid(::std::string* current_bid);

  // optional string current_ask = 12;
  inline bool has_current_ask() const;
  inline void clear_current_ask();
  static const int kCurrentAskFieldNumber = 12;
  inline const ::std::string& current_ask() const;
  inline void set_current_ask(const ::std::string& value);
  inline void set_current_ask(const char* value);
  inline void set_current_ask(const char* value, size_t size);
  inline ::std::string* mutable_current_ask();
  inline ::std::string* release_current_ask();
  inline void set_allocated_current_ask(::std::string* current_ask);

  // optional string volume_trades = 13;
  inline bool has_volume_trades() const;
  inline void clear_volume_trades();
  static const int kVolumeTradesFieldNumber = 13;
  inline const ::std::string& volume_trades() const;
  inline void set_volume_trades(const ::std::string& value);
  inline void set_volume_trades(const char* value);
  inline void set_volume_trades(const char* value, size_t size);
  inline ::std::string* mutable_volume_trades();
  inline ::std::string* release_volume_trades();
  inline void set_allocated_volume_trades(::std::string* volume_trades);

  // optional string volume_assets = 14;
  inline bool has_volume_assets() const;
  inline void clear_volume_assets();
  static const int kVolumeAssetsFieldNumber = 14;
  inline const ::std::string& volume_assets() const;
  inline void set_volume_assets(const ::std::string& value);
  inline void set_volume_assets(const char* value);
  inline void set_volume_assets(const char* value, size_t size);
  inline ::std::string* mutable_volume_assets();
  inline ::std::string* release_volume_assets();
  inline void set_allocated_volume_assets(::std::string* volume_assets);

  // optional string volume_currency = 15;
  inline bool has_volume_currency() const;
  inline void clear_volume_currency();
  static const int kVolumeCurrencyFieldNumber = 15;
  inline const ::std::string& volume_currency() const;
  inline void set_volume_currency(const ::std::string& value);
  inline void set_volume_currency(const char* value);
  inline void set_volume_currency(const char* value, size_t size);
  inline ::std::string* mutable_volume_currency();
  inline ::std::string* release_volume_currency();
  inline void set_allocated_volume_currency(::std::string* volume_currency);

  // optional string recent_highest_bid = 16;
  inline bool has_recent_highest_bid() const;
  inline void clear_recent_highest_bid();
  static const int kRecentHighestBidFieldNumber = 16;
  inline const ::std::string& recent_highest_bid() const;
  inline void set_recent_highest_bid(const ::std::string& value);
  inline void set_recent_highest_bid(const char* value);
  inline void set_recent_highest_bid(const char* value, size_t size);
  inline ::std::string* mutable_recent_highest_bid();
  inline ::std::string* release_recent_highest_bid();
  inline void set_allocated_recent_highest_bid(::std::string* recent_highest_bid);

  // optional string recent_lowest_ask = 17;
  inline bool has_recent_lowest_ask() const;
  inline void clear_recent_lowest_ask();
  static const int kRecentLowestAskFieldNumber = 17;
  inline const ::std::string& recent_lowest_ask() const;
  inline void set_recent_lowest_ask(const ::std::string& value);
  inline void set_recent_lowest_ask(const char* value);
  inline void set_recent_lowest_ask(const char* value, size_t size);
  inline ::std::string* mutable_recent_lowest_ask();
  inline ::std::string* release_recent_lowest_ask();
  inline void set_allocated_recent_lowest_ask(::std::string* recent_lowest_ask);

  // optional string last_sale_date = 18;
  inline bool has_last_sale_date() const;
  inline void clear_last_sale_date();
  static const int kLastSaleDateFieldNumber = 18;
  inline const ::std::string& last_sale_date() const;
  inline void set_last_sale_date(const ::std::string& value);
  inline void set_last_sale_date(const char* value);
  inline void set_last_sale_date(const char* value, size_t size);
  inline ::std::string* mutable_last_sale_date();
  inline ::std::string* release_last_sale_date();
  inline void set_allocated_last_sale_date(::std::string* last_sale_date);

  // @@protoc_insertion_point(class_scope:OTDB.MarketData_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_market_id();
  inline void clear_has_market_id();
  inline void set_has_asset_type_id();
  inline void clear_has_asset_type_id();
  inline void set_has_currency_type_id();
  inline void clear_has_currency_type_id();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_total_assets();
  inline void clear_has_total_assets();
  inline void set_has_number_bids();
  inline void clear_has_number_bids();
  inline void set_has_number_asks();
  inline void clear_has_number_asks();
  inline void set_has_last_sale_price();
  inline void clear_has_last_sale_price();
  inline void set_has_current_bid();
  inline void clear_has_current_bid();
  inline void set_has_current_ask();
  inline void clear_has_current_ask();
  inline void set_has_volume_trades();
  inline void clear_has_volume_trades();
  inline void set_has_volume_assets();
  inline void clear_has_volume_assets();
  inline void set_has_volume_currency();
  inline void clear_has_volume_currency();
  inline void set_has_recent_highest_bid();
  inline void clear_has_recent_highest_bid();
  inline void set_has_recent_lowest_ask();
  inline void clear_has_recent_lowest_ask();
  inline void set_has_last_sale_date();
  inline void clear_has_last_sale_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gui_label_;
  ::std::string* server_id_;
  ::std::string* market_id_;
  ::std::string* asset_type_id_;
  ::std::string* currency_type_id_;
  ::std::string* scale_;
  ::std::string* total_assets_;
  ::std::string* number_bids_;
  ::std::string* number_asks_;
  ::std::string* last_sale_price_;
  ::std::string* current_bid_;
  ::std::string* current_ask_;
  ::std::string* volume_trades_;
  ::std::string* volume_assets_;
  ::std::string* volume_currency_;
  ::std::string* recent_highest_bid_;
  ::std::string* recent_lowest_ask_;
  ::std::string* last_sale_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static MarketData_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class MarketList_InternalPB : public ::google::protobuf::Message {
 public:
  MarketList_InternalPB();
  virtual ~MarketList_InternalPB();

  MarketList_InternalPB(const MarketList_InternalPB& from);

  inline MarketList_InternalPB& operator=(const MarketList_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketList_InternalPB& default_instance();

  void Swap(MarketList_InternalPB* other);

  // implements Message ----------------------------------------------

  MarketList_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketList_InternalPB& from);
  void MergeFrom(const MarketList_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OTDB.MarketData_InternalPB market_data = 1;
  inline int market_data_size() const;
  inline void clear_market_data();
  static const int kMarketDataFieldNumber = 1;
  inline const ::OTDB::MarketData_InternalPB& market_data(int index) const;
  inline ::OTDB::MarketData_InternalPB* mutable_market_data(int index);
  inline ::OTDB::MarketData_InternalPB* add_market_data();
  inline const ::google::protobuf::RepeatedPtrField< ::OTDB::MarketData_InternalPB >&
      market_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::OTDB::MarketData_InternalPB >*
      mutable_market_data();

  // @@protoc_insertion_point(class_scope:OTDB.MarketList_InternalPB)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OTDB::MarketData_InternalPB > market_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static MarketList_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class OfferDataMarket_InternalPB : public ::google::protobuf::Message {
 public:
  OfferDataMarket_InternalPB();
  virtual ~OfferDataMarket_InternalPB();

  OfferDataMarket_InternalPB(const OfferDataMarket_InternalPB& from);

  inline OfferDataMarket_InternalPB& operator=(const OfferDataMarket_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferDataMarket_InternalPB& default_instance();

  void Swap(OfferDataMarket_InternalPB* other);

  // implements Message ----------------------------------------------

  OfferDataMarket_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferDataMarket_InternalPB& from);
  void MergeFrom(const OfferDataMarket_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string transaction_id = 2;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  inline const ::std::string& transaction_id() const;
  inline void set_transaction_id(const ::std::string& value);
  inline void set_transaction_id(const char* value);
  inline void set_transaction_id(const char* value, size_t size);
  inline ::std::string* mutable_transaction_id();
  inline ::std::string* release_transaction_id();
  inline void set_allocated_transaction_id(::std::string* transaction_id);

  // optional string price_per_scale = 3;
  inline bool has_price_per_scale() const;
  inline void clear_price_per_scale();
  static const int kPricePerScaleFieldNumber = 3;
  inline const ::std::string& price_per_scale() const;
  inline void set_price_per_scale(const ::std::string& value);
  inline void set_price_per_scale(const char* value);
  inline void set_price_per_scale(const char* value, size_t size);
  inline ::std::string* mutable_price_per_scale();
  inline ::std::string* release_price_per_scale();
  inline void set_allocated_price_per_scale(::std::string* price_per_scale);

  // optional string available_assets = 4;
  inline bool has_available_assets() const;
  inline void clear_available_assets();
  static const int kAvailableAssetsFieldNumber = 4;
  inline const ::std::string& available_assets() const;
  inline void set_available_assets(const ::std::string& value);
  inline void set_available_assets(const char* value);
  inline void set_available_assets(const char* value, size_t size);
  inline ::std::string* mutable_available_assets();
  inline ::std::string* release_available_assets();
  inline void set_allocated_available_assets(::std::string* available_assets);

  // optional string minimum_increment = 5;
  inline bool has_minimum_increment() const;
  inline void clear_minimum_increment();
  static const int kMinimumIncrementFieldNumber = 5;
  inline const ::std::string& minimum_increment() const;
  inline void set_minimum_increment(const ::std::string& value);
  inline void set_minimum_increment(const char* value);
  inline void set_minimum_increment(const char* value, size_t size);
  inline ::std::string* mutable_minimum_increment();
  inline ::std::string* release_minimum_increment();
  inline void set_allocated_minimum_increment(::std::string* minimum_increment);

  // optional string date = 6;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 6;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // @@protoc_insertion_point(class_scope:OTDB.OfferDataMarket_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_price_per_scale();
  inline void clear_has_price_per_scale();
  inline void set_has_available_assets();
  inline void clear_has_available_assets();
  inline void set_has_minimum_increment();
  inline void clear_has_minimum_increment();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gui_label_;
  ::std::string* transaction_id_;
  ::std::string* price_per_scale_;
  ::std::string* available_assets_;
  ::std::string* minimum_increment_;
  ::std::string* date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static OfferDataMarket_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class OfferListMarket_InternalPB : public ::google::protobuf::Message {
 public:
  OfferListMarket_InternalPB();
  virtual ~OfferListMarket_InternalPB();

  OfferListMarket_InternalPB(const OfferListMarket_InternalPB& from);

  inline OfferListMarket_InternalPB& operator=(const OfferListMarket_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferListMarket_InternalPB& default_instance();

  void Swap(OfferListMarket_InternalPB* other);

  // implements Message ----------------------------------------------

  OfferListMarket_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferListMarket_InternalPB& from);
  void MergeFrom(const OfferListMarket_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OTDB.OfferDataMarket_InternalPB bids = 1;
  inline int bids_size() const;
  inline void clear_bids();
  static const int kBidsFieldNumber = 1;
  inline const ::OTDB::OfferDataMarket_InternalPB& bids(int index) const;
  inline ::OTDB::OfferDataMarket_InternalPB* mutable_bids(int index);
  inline ::OTDB::OfferDataMarket_InternalPB* add_bids();
  inline const ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >&
      bids() const;
  inline ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >*
      mutable_bids();

  // repeated .OTDB.OfferDataMarket_InternalPB asks = 2;
  inline int asks_size() const;
  inline void clear_asks();
  static const int kAsksFieldNumber = 2;
  inline const ::OTDB::OfferDataMarket_InternalPB& asks(int index) const;
  inline ::OTDB::OfferDataMarket_InternalPB* mutable_asks(int index);
  inline ::OTDB::OfferDataMarket_InternalPB* add_asks();
  inline const ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >&
      asks() const;
  inline ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >*
      mutable_asks();

  // @@protoc_insertion_point(class_scope:OTDB.OfferListMarket_InternalPB)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB > bids_;
  ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB > asks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static OfferListMarket_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class TradeDataMarket_InternalPB : public ::google::protobuf::Message {
 public:
  TradeDataMarket_InternalPB();
  virtual ~TradeDataMarket_InternalPB();

  TradeDataMarket_InternalPB(const TradeDataMarket_InternalPB& from);

  inline TradeDataMarket_InternalPB& operator=(const TradeDataMarket_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeDataMarket_InternalPB& default_instance();

  void Swap(TradeDataMarket_InternalPB* other);

  // implements Message ----------------------------------------------

  TradeDataMarket_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeDataMarket_InternalPB& from);
  void MergeFrom(const TradeDataMarket_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string transaction_id = 2;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  inline const ::std::string& transaction_id() const;
  inline void set_transaction_id(const ::std::string& value);
  inline void set_transaction_id(const char* value);
  inline void set_transaction_id(const char* value, size_t size);
  inline ::std::string* mutable_transaction_id();
  inline ::std::string* release_transaction_id();
  inline void set_allocated_transaction_id(::std::string* transaction_id);

  // optional string date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // optional string amount_sold = 5;
  inline bool has_amount_sold() const;
  inline void clear_amount_sold();
  static const int kAmountSoldFieldNumber = 5;
  inline const ::std::string& amount_sold() const;
  inline void set_amount_sold(const ::std::string& value);
  inline void set_amount_sold(const char* value);
  inline void set_amount_sold(const char* value, size_t size);
  inline ::std::string* mutable_amount_sold();
  inline ::std::string* release_amount_sold();
  inline void set_allocated_amount_sold(::std::string* amount_sold);

  // @@protoc_insertion_point(class_scope:OTDB.TradeDataMarket_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_amount_sold();
  inline void clear_has_amount_sold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gui_label_;
  ::std::string* transaction_id_;
  ::std::string* date_;
  ::std::string* price_;
  ::std::string* amount_sold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static TradeDataMarket_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class TradeListMarket_InternalPB : public ::google::protobuf::Message {
 public:
  TradeListMarket_InternalPB();
  virtual ~TradeListMarket_InternalPB();

  TradeListMarket_InternalPB(const TradeListMarket_InternalPB& from);

  inline TradeListMarket_InternalPB& operator=(const TradeListMarket_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeListMarket_InternalPB& default_instance();

  void Swap(TradeListMarket_InternalPB* other);

  // implements Message ----------------------------------------------

  TradeListMarket_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeListMarket_InternalPB& from);
  void MergeFrom(const TradeListMarket_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OTDB.TradeDataMarket_InternalPB trades = 1;
  inline int trades_size() const;
  inline void clear_trades();
  static const int kTradesFieldNumber = 1;
  inline const ::OTDB::TradeDataMarket_InternalPB& trades(int index) const;
  inline ::OTDB::TradeDataMarket_InternalPB* mutable_trades(int index);
  inline ::OTDB::TradeDataMarket_InternalPB* add_trades();
  inline const ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataMarket_InternalPB >&
      trades() const;
  inline ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataMarket_InternalPB >*
      mutable_trades();

  // @@protoc_insertion_point(class_scope:OTDB.TradeListMarket_InternalPB)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataMarket_InternalPB > trades_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static TradeListMarket_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class OfferDataNym_InternalPB : public ::google::protobuf::Message {
 public:
  OfferDataNym_InternalPB();
  virtual ~OfferDataNym_InternalPB();

  OfferDataNym_InternalPB(const OfferDataNym_InternalPB& from);

  inline OfferDataNym_InternalPB& operator=(const OfferDataNym_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferDataNym_InternalPB& default_instance();

  void Swap(OfferDataNym_InternalPB* other);

  // implements Message ----------------------------------------------

  OfferDataNym_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferDataNym_InternalPB& from);
  void MergeFrom(const OfferDataNym_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string valid_from = 2;
  inline bool has_valid_from() const;
  inline void clear_valid_from();
  static const int kValidFromFieldNumber = 2;
  inline const ::std::string& valid_from() const;
  inline void set_valid_from(const ::std::string& value);
  inline void set_valid_from(const char* value);
  inline void set_valid_from(const char* value, size_t size);
  inline ::std::string* mutable_valid_from();
  inline ::std::string* release_valid_from();
  inline void set_allocated_valid_from(::std::string* valid_from);

  // optional string valid_to = 3;
  inline bool has_valid_to() const;
  inline void clear_valid_to();
  static const int kValidToFieldNumber = 3;
  inline const ::std::string& valid_to() const;
  inline void set_valid_to(const ::std::string& value);
  inline void set_valid_to(const char* value);
  inline void set_valid_to(const char* value, size_t size);
  inline ::std::string* mutable_valid_to();
  inline ::std::string* release_valid_to();
  inline void set_allocated_valid_to(::std::string* valid_to);

  // optional string server_id = 4;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 4;
  inline const ::std::string& server_id() const;
  inline void set_server_id(const ::std::string& value);
  inline void set_server_id(const char* value);
  inline void set_server_id(const char* value, size_t size);
  inline ::std::string* mutable_server_id();
  inline ::std::string* release_server_id();
  inline void set_allocated_server_id(::std::string* server_id);

  // optional string asset_type_id = 5;
  inline bool has_asset_type_id() const;
  inline void clear_asset_type_id();
  static const int kAssetTypeIdFieldNumber = 5;
  inline const ::std::string& asset_type_id() const;
  inline void set_asset_type_id(const ::std::string& value);
  inline void set_asset_type_id(const char* value);
  inline void set_asset_type_id(const char* value, size_t size);
  inline ::std::string* mutable_asset_type_id();
  inline ::std::string* release_asset_type_id();
  inline void set_allocated_asset_type_id(::std::string* asset_type_id);

  // optional string asset_acct_id = 6;
  inline bool has_asset_acct_id() const;
  inline void clear_asset_acct_id();
  static const int kAssetAcctIdFieldNumber = 6;
  inline const ::std::string& asset_acct_id() const;
  inline void set_asset_acct_id(const ::std::string& value);
  inline void set_asset_acct_id(const char* value);
  inline void set_asset_acct_id(const char* value, size_t size);
  inline ::std::string* mutable_asset_acct_id();
  inline ::std::string* release_asset_acct_id();
  inline void set_allocated_asset_acct_id(::std::string* asset_acct_id);

  // optional string currency_type_id = 7;
  inline bool has_currency_type_id() const;
  inline void clear_currency_type_id();
  static const int kCurrencyTypeIdFieldNumber = 7;
  inline const ::std::string& currency_type_id() const;
  inline void set_currency_type_id(const ::std::string& value);
  inline void set_currency_type_id(const char* value);
  inline void set_currency_type_id(const char* value, size_t size);
  inline ::std::string* mutable_currency_type_id();
  inline ::std::string* release_currency_type_id();
  inline void set_allocated_currency_type_id(::std::string* currency_type_id);

  // optional string currency_acct_id = 8;
  inline bool has_currency_acct_id() const;
  inline void clear_currency_acct_id();
  static const int kCurrencyAcctIdFieldNumber = 8;
  inline const ::std::string& currency_acct_id() const;
  inline void set_currency_acct_id(const ::std::string& value);
  inline void set_currency_acct_id(const char* value);
  inline void set_currency_acct_id(const char* value, size_t size);
  inline ::std::string* mutable_currency_acct_id();
  inline ::std::string* release_currency_acct_id();
  inline void set_allocated_currency_acct_id(::std::string* currency_acct_id);

  // optional bool selling = 9;
  inline bool has_selling() const;
  inline void clear_selling();
  static const int kSellingFieldNumber = 9;
  inline bool selling() const;
  inline void set_selling(bool value);

  // optional string scale = 10;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 10;
  inline const ::std::string& scale() const;
  inline void set_scale(const ::std::string& value);
  inline void set_scale(const char* value);
  inline void set_scale(const char* value, size_t size);
  inline ::std::string* mutable_scale();
  inline ::std::string* release_scale();
  inline void set_allocated_scale(::std::string* scale);

  // optional string price_per_scale = 11;
  inline bool has_price_per_scale() const;
  inline void clear_price_per_scale();
  static const int kPricePerScaleFieldNumber = 11;
  inline const ::std::string& price_per_scale() const;
  inline void set_price_per_scale(const ::std::string& value);
  inline void set_price_per_scale(const char* value);
  inline void set_price_per_scale(const char* value, size_t size);
  inline ::std::string* mutable_price_per_scale();
  inline ::std::string* release_price_per_scale();
  inline void set_allocated_price_per_scale(::std::string* price_per_scale);

  // optional string transaction_id = 12;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 12;
  inline const ::std::string& transaction_id() const;
  inline void set_transaction_id(const ::std::string& value);
  inline void set_transaction_id(const char* value);
  inline void set_transaction_id(const char* value, size_t size);
  inline ::std::string* mutable_transaction_id();
  inline ::std::string* release_transaction_id();
  inline void set_allocated_transaction_id(::std::string* transaction_id);

  // optional string total_assets = 13;
  inline bool has_total_assets() const;
  inline void clear_total_assets();
  static const int kTotalAssetsFieldNumber = 13;
  inline const ::std::string& total_assets() const;
  inline void set_total_assets(const ::std::string& value);
  inline void set_total_assets(const char* value);
  inline void set_total_assets(const char* value, size_t size);
  inline ::std::string* mutable_total_assets();
  inline ::std::string* release_total_assets();
  inline void set_allocated_total_assets(::std::string* total_assets);

  // optional string finished_so_far = 14;
  inline bool has_finished_so_far() const;
  inline void clear_finished_so_far();
  static const int kFinishedSoFarFieldNumber = 14;
  inline const ::std::string& finished_so_far() const;
  inline void set_finished_so_far(const ::std::string& value);
  inline void set_finished_so_far(const char* value);
  inline void set_finished_so_far(const char* value, size_t size);
  inline ::std::string* mutable_finished_so_far();
  inline ::std::string* release_finished_so_far();
  inline void set_allocated_finished_so_far(::std::string* finished_so_far);

  // optional string minimum_increment = 15;
  inline bool has_minimum_increment() const;
  inline void clear_minimum_increment();
  static const int kMinimumIncrementFieldNumber = 15;
  inline const ::std::string& minimum_increment() const;
  inline void set_minimum_increment(const ::std::string& value);
  inline void set_minimum_increment(const char* value);
  inline void set_minimum_increment(const char* value, size_t size);
  inline ::std::string* mutable_minimum_increment();
  inline ::std::string* release_minimum_increment();
  inline void set_allocated_minimum_increment(::std::string* minimum_increment);

  // optional string stop_sign = 16;
  inline bool has_stop_sign() const;
  inline void clear_stop_sign();
  static const int kStopSignFieldNumber = 16;
  inline const ::std::string& stop_sign() const;
  inline void set_stop_sign(const ::std::string& value);
  inline void set_stop_sign(const char* value);
  inline void set_stop_sign(const char* value, size_t size);
  inline ::std::string* mutable_stop_sign();
  inline ::std::string* release_stop_sign();
  inline void set_allocated_stop_sign(::std::string* stop_sign);

  // optional string stop_price = 17;
  inline bool has_stop_price() const;
  inline void clear_stop_price();
  static const int kStopPriceFieldNumber = 17;
  inline const ::std::string& stop_price() const;
  inline void set_stop_price(const ::std::string& value);
  inline void set_stop_price(const char* value);
  inline void set_stop_price(const char* value, size_t size);
  inline ::std::string* mutable_stop_price();
  inline ::std::string* release_stop_price();
  inline void set_allocated_stop_price(::std::string* stop_price);

  // optional string date = 18;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 18;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // @@protoc_insertion_point(class_scope:OTDB.OfferDataNym_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_valid_from();
  inline void clear_has_valid_from();
  inline void set_has_valid_to();
  inline void clear_has_valid_to();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_asset_type_id();
  inline void clear_has_asset_type_id();
  inline void set_has_asset_acct_id();
  inline void clear_has_asset_acct_id();
  inline void set_has_currency_type_id();
  inline void clear_has_currency_type_id();
  inline void set_has_currency_acct_id();
  inline void clear_has_currency_acct_id();
  inline void set_has_selling();
  inline void clear_has_selling();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_price_per_scale();
  inline void clear_has_price_per_scale();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_total_assets();
  inline void clear_has_total_assets();
  inline void set_has_finished_so_far();
  inline void clear_has_finished_so_far();
  inline void set_has_minimum_increment();
  inline void clear_has_minimum_increment();
  inline void set_has_stop_sign();
  inline void clear_has_stop_sign();
  inline void set_has_stop_price();
  inline void clear_has_stop_price();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gui_label_;
  ::std::string* valid_from_;
  ::std::string* valid_to_;
  ::std::string* server_id_;
  ::std::string* asset_type_id_;
  ::std::string* asset_acct_id_;
  ::std::string* currency_type_id_;
  ::std::string* currency_acct_id_;
  ::std::string* scale_;
  ::std::string* price_per_scale_;
  ::std::string* transaction_id_;
  ::std::string* total_assets_;
  ::std::string* finished_so_far_;
  ::std::string* minimum_increment_;
  ::std::string* stop_sign_;
  ::std::string* stop_price_;
  ::std::string* date_;
  bool selling_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static OfferDataNym_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class OfferListNym_InternalPB : public ::google::protobuf::Message {
 public:
  OfferListNym_InternalPB();
  virtual ~OfferListNym_InternalPB();

  OfferListNym_InternalPB(const OfferListNym_InternalPB& from);

  inline OfferListNym_InternalPB& operator=(const OfferListNym_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfferListNym_InternalPB& default_instance();

  void Swap(OfferListNym_InternalPB* other);

  // implements Message ----------------------------------------------

  OfferListNym_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfferListNym_InternalPB& from);
  void MergeFrom(const OfferListNym_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OTDB.OfferDataNym_InternalPB offers = 1;
  inline int offers_size() const;
  inline void clear_offers();
  static const int kOffersFieldNumber = 1;
  inline const ::OTDB::OfferDataNym_InternalPB& offers(int index) const;
  inline ::OTDB::OfferDataNym_InternalPB* mutable_offers(int index);
  inline ::OTDB::OfferDataNym_InternalPB* add_offers();
  inline const ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataNym_InternalPB >&
      offers() const;
  inline ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataNym_InternalPB >*
      mutable_offers();

  // @@protoc_insertion_point(class_scope:OTDB.OfferListNym_InternalPB)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataNym_InternalPB > offers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static OfferListNym_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class TradeDataNym_InternalPB : public ::google::protobuf::Message {
 public:
  TradeDataNym_InternalPB();
  virtual ~TradeDataNym_InternalPB();

  TradeDataNym_InternalPB(const TradeDataNym_InternalPB& from);

  inline TradeDataNym_InternalPB& operator=(const TradeDataNym_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeDataNym_InternalPB& default_instance();

  void Swap(TradeDataNym_InternalPB* other);

  // implements Message ----------------------------------------------

  TradeDataNym_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeDataNym_InternalPB& from);
  void MergeFrom(const TradeDataNym_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gui_label = 1;
  inline bool has_gui_label() const;
  inline void clear_gui_label();
  static const int kGuiLabelFieldNumber = 1;
  inline const ::std::string& gui_label() const;
  inline void set_gui_label(const ::std::string& value);
  inline void set_gui_label(const char* value);
  inline void set_gui_label(const char* value, size_t size);
  inline ::std::string* mutable_gui_label();
  inline ::std::string* release_gui_label();
  inline void set_allocated_gui_label(::std::string* gui_label);

  // optional string completed_count = 2;
  inline bool has_completed_count() const;
  inline void clear_completed_count();
  static const int kCompletedCountFieldNumber = 2;
  inline const ::std::string& completed_count() const;
  inline void set_completed_count(const ::std::string& value);
  inline void set_completed_count(const char* value);
  inline void set_completed_count(const char* value, size_t size);
  inline ::std::string* mutable_completed_count();
  inline ::std::string* release_completed_count();
  inline void set_allocated_completed_count(::std::string* completed_count);

  // optional string date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  inline void set_allocated_price(::std::string* price);

  // optional string amount_sold = 5;
  inline bool has_amount_sold() const;
  inline void clear_amount_sold();
  static const int kAmountSoldFieldNumber = 5;
  inline const ::std::string& amount_sold() const;
  inline void set_amount_sold(const ::std::string& value);
  inline void set_amount_sold(const char* value);
  inline void set_amount_sold(const char* value, size_t size);
  inline ::std::string* mutable_amount_sold();
  inline ::std::string* release_amount_sold();
  inline void set_allocated_amount_sold(::std::string* amount_sold);

  // optional string transaction_id = 6;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 6;
  inline const ::std::string& transaction_id() const;
  inline void set_transaction_id(const ::std::string& value);
  inline void set_transaction_id(const char* value);
  inline void set_transaction_id(const char* value, size_t size);
  inline ::std::string* mutable_transaction_id();
  inline ::std::string* release_transaction_id();
  inline void set_allocated_transaction_id(::std::string* transaction_id);

  // optional string updated_id = 7;
  inline bool has_updated_id() const;
  inline void clear_updated_id();
  static const int kUpdatedIdFieldNumber = 7;
  inline const ::std::string& updated_id() const;
  inline void set_updated_id(const ::std::string& value);
  inline void set_updated_id(const char* value);
  inline void set_updated_id(const char* value, size_t size);
  inline ::std::string* mutable_updated_id();
  inline ::std::string* release_updated_id();
  inline void set_allocated_updated_id(::std::string* updated_id);

  // optional string offer_price = 8;
  inline bool has_offer_price() const;
  inline void clear_offer_price();
  static const int kOfferPriceFieldNumber = 8;
  inline const ::std::string& offer_price() const;
  inline void set_offer_price(const ::std::string& value);
  inline void set_offer_price(const char* value);
  inline void set_offer_price(const char* value, size_t size);
  inline ::std::string* mutable_offer_price();
  inline ::std::string* release_offer_price();
  inline void set_allocated_offer_price(::std::string* offer_price);

  // optional string finished_so_far = 9;
  inline bool has_finished_so_far() const;
  inline void clear_finished_so_far();
  static const int kFinishedSoFarFieldNumber = 9;
  inline const ::std::string& finished_so_far() const;
  inline void set_finished_so_far(const ::std::string& value);
  inline void set_finished_so_far(const char* value);
  inline void set_finished_so_far(const char* value, size_t size);
  inline ::std::string* mutable_finished_so_far();
  inline ::std::string* release_finished_so_far();
  inline void set_allocated_finished_so_far(::std::string* finished_so_far);

  // optional string asset_id = 10;
  inline bool has_asset_id() const;
  inline void clear_asset_id();
  static const int kAssetIdFieldNumber = 10;
  inline const ::std::string& asset_id() const;
  inline void set_asset_id(const ::std::string& value);
  inline void set_asset_id(const char* value);
  inline void set_asset_id(const char* value, size_t size);
  inline ::std::string* mutable_asset_id();
  inline ::std::string* release_asset_id();
  inline void set_allocated_asset_id(::std::string* asset_id);

  // optional string currency_id = 11;
  inline bool has_currency_id() const;
  inline void clear_currency_id();
  static const int kCurrencyIdFieldNumber = 11;
  inline const ::std::string& currency_id() const;
  inline void set_currency_id(const ::std::string& value);
  inline void set_currency_id(const char* value);
  inline void set_currency_id(const char* value, size_t size);
  inline ::std::string* mutable_currency_id();
  inline ::std::string* release_currency_id();
  inline void set_allocated_currency_id(::std::string* currency_id);

  // optional string currency_paid = 12;
  inline bool has_currency_paid() const;
  inline void clear_currency_paid();
  static const int kCurrencyPaidFieldNumber = 12;
  inline const ::std::string& currency_paid() const;
  inline void set_currency_paid(const ::std::string& value);
  inline void set_currency_paid(const char* value);
  inline void set_currency_paid(const char* value, size_t size);
  inline ::std::string* mutable_currency_paid();
  inline ::std::string* release_currency_paid();
  inline void set_allocated_currency_paid(::std::string* currency_paid);

  // @@protoc_insertion_point(class_scope:OTDB.TradeDataNym_InternalPB)
 private:
  inline void set_has_gui_label();
  inline void clear_has_gui_label();
  inline void set_has_completed_count();
  inline void clear_has_completed_count();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_amount_sold();
  inline void clear_has_amount_sold();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_updated_id();
  inline void clear_has_updated_id();
  inline void set_has_offer_price();
  inline void clear_has_offer_price();
  inline void set_has_finished_so_far();
  inline void clear_has_finished_so_far();
  inline void set_has_asset_id();
  inline void clear_has_asset_id();
  inline void set_has_currency_id();
  inline void clear_has_currency_id();
  inline void set_has_currency_paid();
  inline void clear_has_currency_paid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gui_label_;
  ::std::string* completed_count_;
  ::std::string* date_;
  ::std::string* price_;
  ::std::string* amount_sold_;
  ::std::string* transaction_id_;
  ::std::string* updated_id_;
  ::std::string* offer_price_;
  ::std::string* finished_so_far_;
  ::std::string* asset_id_;
  ::std::string* currency_id_;
  ::std::string* currency_paid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static TradeDataNym_InternalPB* default_instance_;
};
// -------------------------------------------------------------------

class TradeListNym_InternalPB : public ::google::protobuf::Message {
 public:
  TradeListNym_InternalPB();
  virtual ~TradeListNym_InternalPB();

  TradeListNym_InternalPB(const TradeListNym_InternalPB& from);

  inline TradeListNym_InternalPB& operator=(const TradeListNym_InternalPB& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeListNym_InternalPB& default_instance();

  void Swap(TradeListNym_InternalPB* other);

  // implements Message ----------------------------------------------

  TradeListNym_InternalPB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeListNym_InternalPB& from);
  void MergeFrom(const TradeListNym_InternalPB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OTDB.TradeDataNym_InternalPB trades = 1;
  inline int trades_size() const;
  inline void clear_trades();
  static const int kTradesFieldNumber = 1;
  inline const ::OTDB::TradeDataNym_InternalPB& trades(int index) const;
  inline ::OTDB::TradeDataNym_InternalPB* mutable_trades(int index);
  inline ::OTDB::TradeDataNym_InternalPB* add_trades();
  inline const ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataNym_InternalPB >&
      trades() const;
  inline ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataNym_InternalPB >*
      mutable_trades();

  // @@protoc_insertion_point(class_scope:OTDB.TradeListNym_InternalPB)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataNym_InternalPB > trades_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Markets_2eproto();
  friend void protobuf_AssignDesc_Markets_2eproto();
  friend void protobuf_ShutdownFile_Markets_2eproto();

  void InitAsDefaultInstance();
  static TradeListNym_InternalPB* default_instance_;
};
// ===================================================================


// ===================================================================

// MarketData_InternalPB

// optional string gui_label = 1;
inline bool MarketData_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketData_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketData_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketData_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& MarketData_InternalPB::gui_label() const {
  return *gui_label_;
}
inline void MarketData_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void MarketData_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void MarketData_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  return gui_label_;
}
inline ::std::string* MarketData_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_id = 2;
inline bool MarketData_InternalPB::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketData_InternalPB::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketData_InternalPB::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketData_InternalPB::clear_server_id() {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    server_id_->clear();
  }
  clear_has_server_id();
}
inline const ::std::string& MarketData_InternalPB::server_id() const {
  return *server_id_;
}
inline void MarketData_InternalPB::set_server_id(const ::std::string& value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void MarketData_InternalPB::set_server_id(const char* value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void MarketData_InternalPB::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_server_id() {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  return server_id_;
}
inline ::std::string* MarketData_InternalPB::release_server_id() {
  clear_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_id_;
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_server_id(::std::string* server_id) {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    delete server_id_;
  }
  if (server_id) {
    set_has_server_id();
    server_id_ = server_id;
  } else {
    clear_has_server_id();
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string market_id = 3;
inline bool MarketData_InternalPB::has_market_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketData_InternalPB::set_has_market_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketData_InternalPB::clear_has_market_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketData_InternalPB::clear_market_id() {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    market_id_->clear();
  }
  clear_has_market_id();
}
inline const ::std::string& MarketData_InternalPB::market_id() const {
  return *market_id_;
}
inline void MarketData_InternalPB::set_market_id(const ::std::string& value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void MarketData_InternalPB::set_market_id(const char* value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void MarketData_InternalPB::set_market_id(const char* value, size_t size) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_market_id() {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  return market_id_;
}
inline ::std::string* MarketData_InternalPB::release_market_id() {
  clear_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_id_;
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_market_id(::std::string* market_id) {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_id_;
  }
  if (market_id) {
    set_has_market_id();
    market_id_ = market_id;
  } else {
    clear_has_market_id();
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string asset_type_id = 4;
inline bool MarketData_InternalPB::has_asset_type_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketData_InternalPB::set_has_asset_type_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketData_InternalPB::clear_has_asset_type_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketData_InternalPB::clear_asset_type_id() {
  if (asset_type_id_ != &::google::protobuf::internal::kEmptyString) {
    asset_type_id_->clear();
  }
  clear_has_asset_type_id();
}
inline const ::std::string& MarketData_InternalPB::asset_type_id() const {
  return *asset_type_id_;
}
inline void MarketData_InternalPB::set_asset_type_id(const ::std::string& value) {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  asset_type_id_->assign(value);
}
inline void MarketData_InternalPB::set_asset_type_id(const char* value) {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  asset_type_id_->assign(value);
}
inline void MarketData_InternalPB::set_asset_type_id(const char* value, size_t size) {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  asset_type_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_asset_type_id() {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  return asset_type_id_;
}
inline ::std::string* MarketData_InternalPB::release_asset_type_id() {
  clear_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asset_type_id_;
    asset_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_asset_type_id(::std::string* asset_type_id) {
  if (asset_type_id_ != &::google::protobuf::internal::kEmptyString) {
    delete asset_type_id_;
  }
  if (asset_type_id) {
    set_has_asset_type_id();
    asset_type_id_ = asset_type_id;
  } else {
    clear_has_asset_type_id();
    asset_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency_type_id = 5;
inline bool MarketData_InternalPB::has_currency_type_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketData_InternalPB::set_has_currency_type_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketData_InternalPB::clear_has_currency_type_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketData_InternalPB::clear_currency_type_id() {
  if (currency_type_id_ != &::google::protobuf::internal::kEmptyString) {
    currency_type_id_->clear();
  }
  clear_has_currency_type_id();
}
inline const ::std::string& MarketData_InternalPB::currency_type_id() const {
  return *currency_type_id_;
}
inline void MarketData_InternalPB::set_currency_type_id(const ::std::string& value) {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  currency_type_id_->assign(value);
}
inline void MarketData_InternalPB::set_currency_type_id(const char* value) {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  currency_type_id_->assign(value);
}
inline void MarketData_InternalPB::set_currency_type_id(const char* value, size_t size) {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  currency_type_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_currency_type_id() {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  return currency_type_id_;
}
inline ::std::string* MarketData_InternalPB::release_currency_type_id() {
  clear_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_type_id_;
    currency_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_currency_type_id(::std::string* currency_type_id) {
  if (currency_type_id_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_type_id_;
  }
  if (currency_type_id) {
    set_has_currency_type_id();
    currency_type_id_ = currency_type_id;
  } else {
    clear_has_currency_type_id();
    currency_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string scale = 6;
inline bool MarketData_InternalPB::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketData_InternalPB::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketData_InternalPB::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketData_InternalPB::clear_scale() {
  if (scale_ != &::google::protobuf::internal::kEmptyString) {
    scale_->clear();
  }
  clear_has_scale();
}
inline const ::std::string& MarketData_InternalPB::scale() const {
  return *scale_;
}
inline void MarketData_InternalPB::set_scale(const ::std::string& value) {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  scale_->assign(value);
}
inline void MarketData_InternalPB::set_scale(const char* value) {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  scale_->assign(value);
}
inline void MarketData_InternalPB::set_scale(const char* value, size_t size) {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  scale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_scale() {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  return scale_;
}
inline ::std::string* MarketData_InternalPB::release_scale() {
  clear_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scale_;
    scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_scale(::std::string* scale) {
  if (scale_ != &::google::protobuf::internal::kEmptyString) {
    delete scale_;
  }
  if (scale) {
    set_has_scale();
    scale_ = scale;
  } else {
    clear_has_scale();
    scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string total_assets = 7;
inline bool MarketData_InternalPB::has_total_assets() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketData_InternalPB::set_has_total_assets() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketData_InternalPB::clear_has_total_assets() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketData_InternalPB::clear_total_assets() {
  if (total_assets_ != &::google::protobuf::internal::kEmptyString) {
    total_assets_->clear();
  }
  clear_has_total_assets();
}
inline const ::std::string& MarketData_InternalPB::total_assets() const {
  return *total_assets_;
}
inline void MarketData_InternalPB::set_total_assets(const ::std::string& value) {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  total_assets_->assign(value);
}
inline void MarketData_InternalPB::set_total_assets(const char* value) {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  total_assets_->assign(value);
}
inline void MarketData_InternalPB::set_total_assets(const char* value, size_t size) {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  total_assets_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_total_assets() {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  return total_assets_;
}
inline ::std::string* MarketData_InternalPB::release_total_assets() {
  clear_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_assets_;
    total_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_total_assets(::std::string* total_assets) {
  if (total_assets_ != &::google::protobuf::internal::kEmptyString) {
    delete total_assets_;
  }
  if (total_assets) {
    set_has_total_assets();
    total_assets_ = total_assets;
  } else {
    clear_has_total_assets();
    total_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string number_bids = 8;
inline bool MarketData_InternalPB::has_number_bids() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketData_InternalPB::set_has_number_bids() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketData_InternalPB::clear_has_number_bids() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketData_InternalPB::clear_number_bids() {
  if (number_bids_ != &::google::protobuf::internal::kEmptyString) {
    number_bids_->clear();
  }
  clear_has_number_bids();
}
inline const ::std::string& MarketData_InternalPB::number_bids() const {
  return *number_bids_;
}
inline void MarketData_InternalPB::set_number_bids(const ::std::string& value) {
  set_has_number_bids();
  if (number_bids_ == &::google::protobuf::internal::kEmptyString) {
    number_bids_ = new ::std::string;
  }
  number_bids_->assign(value);
}
inline void MarketData_InternalPB::set_number_bids(const char* value) {
  set_has_number_bids();
  if (number_bids_ == &::google::protobuf::internal::kEmptyString) {
    number_bids_ = new ::std::string;
  }
  number_bids_->assign(value);
}
inline void MarketData_InternalPB::set_number_bids(const char* value, size_t size) {
  set_has_number_bids();
  if (number_bids_ == &::google::protobuf::internal::kEmptyString) {
    number_bids_ = new ::std::string;
  }
  number_bids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_number_bids() {
  set_has_number_bids();
  if (number_bids_ == &::google::protobuf::internal::kEmptyString) {
    number_bids_ = new ::std::string;
  }
  return number_bids_;
}
inline ::std::string* MarketData_InternalPB::release_number_bids() {
  clear_has_number_bids();
  if (number_bids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_bids_;
    number_bids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_number_bids(::std::string* number_bids) {
  if (number_bids_ != &::google::protobuf::internal::kEmptyString) {
    delete number_bids_;
  }
  if (number_bids) {
    set_has_number_bids();
    number_bids_ = number_bids;
  } else {
    clear_has_number_bids();
    number_bids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string number_asks = 9;
inline bool MarketData_InternalPB::has_number_asks() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketData_InternalPB::set_has_number_asks() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketData_InternalPB::clear_has_number_asks() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketData_InternalPB::clear_number_asks() {
  if (number_asks_ != &::google::protobuf::internal::kEmptyString) {
    number_asks_->clear();
  }
  clear_has_number_asks();
}
inline const ::std::string& MarketData_InternalPB::number_asks() const {
  return *number_asks_;
}
inline void MarketData_InternalPB::set_number_asks(const ::std::string& value) {
  set_has_number_asks();
  if (number_asks_ == &::google::protobuf::internal::kEmptyString) {
    number_asks_ = new ::std::string;
  }
  number_asks_->assign(value);
}
inline void MarketData_InternalPB::set_number_asks(const char* value) {
  set_has_number_asks();
  if (number_asks_ == &::google::protobuf::internal::kEmptyString) {
    number_asks_ = new ::std::string;
  }
  number_asks_->assign(value);
}
inline void MarketData_InternalPB::set_number_asks(const char* value, size_t size) {
  set_has_number_asks();
  if (number_asks_ == &::google::protobuf::internal::kEmptyString) {
    number_asks_ = new ::std::string;
  }
  number_asks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_number_asks() {
  set_has_number_asks();
  if (number_asks_ == &::google::protobuf::internal::kEmptyString) {
    number_asks_ = new ::std::string;
  }
  return number_asks_;
}
inline ::std::string* MarketData_InternalPB::release_number_asks() {
  clear_has_number_asks();
  if (number_asks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = number_asks_;
    number_asks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_number_asks(::std::string* number_asks) {
  if (number_asks_ != &::google::protobuf::internal::kEmptyString) {
    delete number_asks_;
  }
  if (number_asks) {
    set_has_number_asks();
    number_asks_ = number_asks;
  } else {
    clear_has_number_asks();
    number_asks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string last_sale_price = 10;
inline bool MarketData_InternalPB::has_last_sale_price() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MarketData_InternalPB::set_has_last_sale_price() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MarketData_InternalPB::clear_has_last_sale_price() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MarketData_InternalPB::clear_last_sale_price() {
  if (last_sale_price_ != &::google::protobuf::internal::kEmptyString) {
    last_sale_price_->clear();
  }
  clear_has_last_sale_price();
}
inline const ::std::string& MarketData_InternalPB::last_sale_price() const {
  return *last_sale_price_;
}
inline void MarketData_InternalPB::set_last_sale_price(const ::std::string& value) {
  set_has_last_sale_price();
  if (last_sale_price_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_price_ = new ::std::string;
  }
  last_sale_price_->assign(value);
}
inline void MarketData_InternalPB::set_last_sale_price(const char* value) {
  set_has_last_sale_price();
  if (last_sale_price_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_price_ = new ::std::string;
  }
  last_sale_price_->assign(value);
}
inline void MarketData_InternalPB::set_last_sale_price(const char* value, size_t size) {
  set_has_last_sale_price();
  if (last_sale_price_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_price_ = new ::std::string;
  }
  last_sale_price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_last_sale_price() {
  set_has_last_sale_price();
  if (last_sale_price_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_price_ = new ::std::string;
  }
  return last_sale_price_;
}
inline ::std::string* MarketData_InternalPB::release_last_sale_price() {
  clear_has_last_sale_price();
  if (last_sale_price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_sale_price_;
    last_sale_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_last_sale_price(::std::string* last_sale_price) {
  if (last_sale_price_ != &::google::protobuf::internal::kEmptyString) {
    delete last_sale_price_;
  }
  if (last_sale_price) {
    set_has_last_sale_price();
    last_sale_price_ = last_sale_price;
  } else {
    clear_has_last_sale_price();
    last_sale_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string current_bid = 11;
inline bool MarketData_InternalPB::has_current_bid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MarketData_InternalPB::set_has_current_bid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MarketData_InternalPB::clear_has_current_bid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MarketData_InternalPB::clear_current_bid() {
  if (current_bid_ != &::google::protobuf::internal::kEmptyString) {
    current_bid_->clear();
  }
  clear_has_current_bid();
}
inline const ::std::string& MarketData_InternalPB::current_bid() const {
  return *current_bid_;
}
inline void MarketData_InternalPB::set_current_bid(const ::std::string& value) {
  set_has_current_bid();
  if (current_bid_ == &::google::protobuf::internal::kEmptyString) {
    current_bid_ = new ::std::string;
  }
  current_bid_->assign(value);
}
inline void MarketData_InternalPB::set_current_bid(const char* value) {
  set_has_current_bid();
  if (current_bid_ == &::google::protobuf::internal::kEmptyString) {
    current_bid_ = new ::std::string;
  }
  current_bid_->assign(value);
}
inline void MarketData_InternalPB::set_current_bid(const char* value, size_t size) {
  set_has_current_bid();
  if (current_bid_ == &::google::protobuf::internal::kEmptyString) {
    current_bid_ = new ::std::string;
  }
  current_bid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_current_bid() {
  set_has_current_bid();
  if (current_bid_ == &::google::protobuf::internal::kEmptyString) {
    current_bid_ = new ::std::string;
  }
  return current_bid_;
}
inline ::std::string* MarketData_InternalPB::release_current_bid() {
  clear_has_current_bid();
  if (current_bid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = current_bid_;
    current_bid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_current_bid(::std::string* current_bid) {
  if (current_bid_ != &::google::protobuf::internal::kEmptyString) {
    delete current_bid_;
  }
  if (current_bid) {
    set_has_current_bid();
    current_bid_ = current_bid;
  } else {
    clear_has_current_bid();
    current_bid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string current_ask = 12;
inline bool MarketData_InternalPB::has_current_ask() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MarketData_InternalPB::set_has_current_ask() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MarketData_InternalPB::clear_has_current_ask() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MarketData_InternalPB::clear_current_ask() {
  if (current_ask_ != &::google::protobuf::internal::kEmptyString) {
    current_ask_->clear();
  }
  clear_has_current_ask();
}
inline const ::std::string& MarketData_InternalPB::current_ask() const {
  return *current_ask_;
}
inline void MarketData_InternalPB::set_current_ask(const ::std::string& value) {
  set_has_current_ask();
  if (current_ask_ == &::google::protobuf::internal::kEmptyString) {
    current_ask_ = new ::std::string;
  }
  current_ask_->assign(value);
}
inline void MarketData_InternalPB::set_current_ask(const char* value) {
  set_has_current_ask();
  if (current_ask_ == &::google::protobuf::internal::kEmptyString) {
    current_ask_ = new ::std::string;
  }
  current_ask_->assign(value);
}
inline void MarketData_InternalPB::set_current_ask(const char* value, size_t size) {
  set_has_current_ask();
  if (current_ask_ == &::google::protobuf::internal::kEmptyString) {
    current_ask_ = new ::std::string;
  }
  current_ask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_current_ask() {
  set_has_current_ask();
  if (current_ask_ == &::google::protobuf::internal::kEmptyString) {
    current_ask_ = new ::std::string;
  }
  return current_ask_;
}
inline ::std::string* MarketData_InternalPB::release_current_ask() {
  clear_has_current_ask();
  if (current_ask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = current_ask_;
    current_ask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_current_ask(::std::string* current_ask) {
  if (current_ask_ != &::google::protobuf::internal::kEmptyString) {
    delete current_ask_;
  }
  if (current_ask) {
    set_has_current_ask();
    current_ask_ = current_ask;
  } else {
    clear_has_current_ask();
    current_ask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_trades = 13;
inline bool MarketData_InternalPB::has_volume_trades() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MarketData_InternalPB::set_has_volume_trades() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MarketData_InternalPB::clear_has_volume_trades() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MarketData_InternalPB::clear_volume_trades() {
  if (volume_trades_ != &::google::protobuf::internal::kEmptyString) {
    volume_trades_->clear();
  }
  clear_has_volume_trades();
}
inline const ::std::string& MarketData_InternalPB::volume_trades() const {
  return *volume_trades_;
}
inline void MarketData_InternalPB::set_volume_trades(const ::std::string& value) {
  set_has_volume_trades();
  if (volume_trades_ == &::google::protobuf::internal::kEmptyString) {
    volume_trades_ = new ::std::string;
  }
  volume_trades_->assign(value);
}
inline void MarketData_InternalPB::set_volume_trades(const char* value) {
  set_has_volume_trades();
  if (volume_trades_ == &::google::protobuf::internal::kEmptyString) {
    volume_trades_ = new ::std::string;
  }
  volume_trades_->assign(value);
}
inline void MarketData_InternalPB::set_volume_trades(const char* value, size_t size) {
  set_has_volume_trades();
  if (volume_trades_ == &::google::protobuf::internal::kEmptyString) {
    volume_trades_ = new ::std::string;
  }
  volume_trades_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_volume_trades() {
  set_has_volume_trades();
  if (volume_trades_ == &::google::protobuf::internal::kEmptyString) {
    volume_trades_ = new ::std::string;
  }
  return volume_trades_;
}
inline ::std::string* MarketData_InternalPB::release_volume_trades() {
  clear_has_volume_trades();
  if (volume_trades_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_trades_;
    volume_trades_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_volume_trades(::std::string* volume_trades) {
  if (volume_trades_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_trades_;
  }
  if (volume_trades) {
    set_has_volume_trades();
    volume_trades_ = volume_trades;
  } else {
    clear_has_volume_trades();
    volume_trades_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_assets = 14;
inline bool MarketData_InternalPB::has_volume_assets() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MarketData_InternalPB::set_has_volume_assets() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MarketData_InternalPB::clear_has_volume_assets() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MarketData_InternalPB::clear_volume_assets() {
  if (volume_assets_ != &::google::protobuf::internal::kEmptyString) {
    volume_assets_->clear();
  }
  clear_has_volume_assets();
}
inline const ::std::string& MarketData_InternalPB::volume_assets() const {
  return *volume_assets_;
}
inline void MarketData_InternalPB::set_volume_assets(const ::std::string& value) {
  set_has_volume_assets();
  if (volume_assets_ == &::google::protobuf::internal::kEmptyString) {
    volume_assets_ = new ::std::string;
  }
  volume_assets_->assign(value);
}
inline void MarketData_InternalPB::set_volume_assets(const char* value) {
  set_has_volume_assets();
  if (volume_assets_ == &::google::protobuf::internal::kEmptyString) {
    volume_assets_ = new ::std::string;
  }
  volume_assets_->assign(value);
}
inline void MarketData_InternalPB::set_volume_assets(const char* value, size_t size) {
  set_has_volume_assets();
  if (volume_assets_ == &::google::protobuf::internal::kEmptyString) {
    volume_assets_ = new ::std::string;
  }
  volume_assets_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_volume_assets() {
  set_has_volume_assets();
  if (volume_assets_ == &::google::protobuf::internal::kEmptyString) {
    volume_assets_ = new ::std::string;
  }
  return volume_assets_;
}
inline ::std::string* MarketData_InternalPB::release_volume_assets() {
  clear_has_volume_assets();
  if (volume_assets_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_assets_;
    volume_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_volume_assets(::std::string* volume_assets) {
  if (volume_assets_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_assets_;
  }
  if (volume_assets) {
    set_has_volume_assets();
    volume_assets_ = volume_assets;
  } else {
    clear_has_volume_assets();
    volume_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_currency = 15;
inline bool MarketData_InternalPB::has_volume_currency() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MarketData_InternalPB::set_has_volume_currency() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MarketData_InternalPB::clear_has_volume_currency() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MarketData_InternalPB::clear_volume_currency() {
  if (volume_currency_ != &::google::protobuf::internal::kEmptyString) {
    volume_currency_->clear();
  }
  clear_has_volume_currency();
}
inline const ::std::string& MarketData_InternalPB::volume_currency() const {
  return *volume_currency_;
}
inline void MarketData_InternalPB::set_volume_currency(const ::std::string& value) {
  set_has_volume_currency();
  if (volume_currency_ == &::google::protobuf::internal::kEmptyString) {
    volume_currency_ = new ::std::string;
  }
  volume_currency_->assign(value);
}
inline void MarketData_InternalPB::set_volume_currency(const char* value) {
  set_has_volume_currency();
  if (volume_currency_ == &::google::protobuf::internal::kEmptyString) {
    volume_currency_ = new ::std::string;
  }
  volume_currency_->assign(value);
}
inline void MarketData_InternalPB::set_volume_currency(const char* value, size_t size) {
  set_has_volume_currency();
  if (volume_currency_ == &::google::protobuf::internal::kEmptyString) {
    volume_currency_ = new ::std::string;
  }
  volume_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_volume_currency() {
  set_has_volume_currency();
  if (volume_currency_ == &::google::protobuf::internal::kEmptyString) {
    volume_currency_ = new ::std::string;
  }
  return volume_currency_;
}
inline ::std::string* MarketData_InternalPB::release_volume_currency() {
  clear_has_volume_currency();
  if (volume_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_currency_;
    volume_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_volume_currency(::std::string* volume_currency) {
  if (volume_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_currency_;
  }
  if (volume_currency) {
    set_has_volume_currency();
    volume_currency_ = volume_currency;
  } else {
    clear_has_volume_currency();
    volume_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string recent_highest_bid = 16;
inline bool MarketData_InternalPB::has_recent_highest_bid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MarketData_InternalPB::set_has_recent_highest_bid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MarketData_InternalPB::clear_has_recent_highest_bid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MarketData_InternalPB::clear_recent_highest_bid() {
  if (recent_highest_bid_ != &::google::protobuf::internal::kEmptyString) {
    recent_highest_bid_->clear();
  }
  clear_has_recent_highest_bid();
}
inline const ::std::string& MarketData_InternalPB::recent_highest_bid() const {
  return *recent_highest_bid_;
}
inline void MarketData_InternalPB::set_recent_highest_bid(const ::std::string& value) {
  set_has_recent_highest_bid();
  if (recent_highest_bid_ == &::google::protobuf::internal::kEmptyString) {
    recent_highest_bid_ = new ::std::string;
  }
  recent_highest_bid_->assign(value);
}
inline void MarketData_InternalPB::set_recent_highest_bid(const char* value) {
  set_has_recent_highest_bid();
  if (recent_highest_bid_ == &::google::protobuf::internal::kEmptyString) {
    recent_highest_bid_ = new ::std::string;
  }
  recent_highest_bid_->assign(value);
}
inline void MarketData_InternalPB::set_recent_highest_bid(const char* value, size_t size) {
  set_has_recent_highest_bid();
  if (recent_highest_bid_ == &::google::protobuf::internal::kEmptyString) {
    recent_highest_bid_ = new ::std::string;
  }
  recent_highest_bid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_recent_highest_bid() {
  set_has_recent_highest_bid();
  if (recent_highest_bid_ == &::google::protobuf::internal::kEmptyString) {
    recent_highest_bid_ = new ::std::string;
  }
  return recent_highest_bid_;
}
inline ::std::string* MarketData_InternalPB::release_recent_highest_bid() {
  clear_has_recent_highest_bid();
  if (recent_highest_bid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recent_highest_bid_;
    recent_highest_bid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_recent_highest_bid(::std::string* recent_highest_bid) {
  if (recent_highest_bid_ != &::google::protobuf::internal::kEmptyString) {
    delete recent_highest_bid_;
  }
  if (recent_highest_bid) {
    set_has_recent_highest_bid();
    recent_highest_bid_ = recent_highest_bid;
  } else {
    clear_has_recent_highest_bid();
    recent_highest_bid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string recent_lowest_ask = 17;
inline bool MarketData_InternalPB::has_recent_lowest_ask() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MarketData_InternalPB::set_has_recent_lowest_ask() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MarketData_InternalPB::clear_has_recent_lowest_ask() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MarketData_InternalPB::clear_recent_lowest_ask() {
  if (recent_lowest_ask_ != &::google::protobuf::internal::kEmptyString) {
    recent_lowest_ask_->clear();
  }
  clear_has_recent_lowest_ask();
}
inline const ::std::string& MarketData_InternalPB::recent_lowest_ask() const {
  return *recent_lowest_ask_;
}
inline void MarketData_InternalPB::set_recent_lowest_ask(const ::std::string& value) {
  set_has_recent_lowest_ask();
  if (recent_lowest_ask_ == &::google::protobuf::internal::kEmptyString) {
    recent_lowest_ask_ = new ::std::string;
  }
  recent_lowest_ask_->assign(value);
}
inline void MarketData_InternalPB::set_recent_lowest_ask(const char* value) {
  set_has_recent_lowest_ask();
  if (recent_lowest_ask_ == &::google::protobuf::internal::kEmptyString) {
    recent_lowest_ask_ = new ::std::string;
  }
  recent_lowest_ask_->assign(value);
}
inline void MarketData_InternalPB::set_recent_lowest_ask(const char* value, size_t size) {
  set_has_recent_lowest_ask();
  if (recent_lowest_ask_ == &::google::protobuf::internal::kEmptyString) {
    recent_lowest_ask_ = new ::std::string;
  }
  recent_lowest_ask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_recent_lowest_ask() {
  set_has_recent_lowest_ask();
  if (recent_lowest_ask_ == &::google::protobuf::internal::kEmptyString) {
    recent_lowest_ask_ = new ::std::string;
  }
  return recent_lowest_ask_;
}
inline ::std::string* MarketData_InternalPB::release_recent_lowest_ask() {
  clear_has_recent_lowest_ask();
  if (recent_lowest_ask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recent_lowest_ask_;
    recent_lowest_ask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_recent_lowest_ask(::std::string* recent_lowest_ask) {
  if (recent_lowest_ask_ != &::google::protobuf::internal::kEmptyString) {
    delete recent_lowest_ask_;
  }
  if (recent_lowest_ask) {
    set_has_recent_lowest_ask();
    recent_lowest_ask_ = recent_lowest_ask;
  } else {
    clear_has_recent_lowest_ask();
    recent_lowest_ask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string last_sale_date = 18;
inline bool MarketData_InternalPB::has_last_sale_date() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MarketData_InternalPB::set_has_last_sale_date() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MarketData_InternalPB::clear_has_last_sale_date() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MarketData_InternalPB::clear_last_sale_date() {
  if (last_sale_date_ != &::google::protobuf::internal::kEmptyString) {
    last_sale_date_->clear();
  }
  clear_has_last_sale_date();
}
inline const ::std::string& MarketData_InternalPB::last_sale_date() const {
  return *last_sale_date_;
}
inline void MarketData_InternalPB::set_last_sale_date(const ::std::string& value) {
  set_has_last_sale_date();
  if (last_sale_date_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_date_ = new ::std::string;
  }
  last_sale_date_->assign(value);
}
inline void MarketData_InternalPB::set_last_sale_date(const char* value) {
  set_has_last_sale_date();
  if (last_sale_date_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_date_ = new ::std::string;
  }
  last_sale_date_->assign(value);
}
inline void MarketData_InternalPB::set_last_sale_date(const char* value, size_t size) {
  set_has_last_sale_date();
  if (last_sale_date_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_date_ = new ::std::string;
  }
  last_sale_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketData_InternalPB::mutable_last_sale_date() {
  set_has_last_sale_date();
  if (last_sale_date_ == &::google::protobuf::internal::kEmptyString) {
    last_sale_date_ = new ::std::string;
  }
  return last_sale_date_;
}
inline ::std::string* MarketData_InternalPB::release_last_sale_date() {
  clear_has_last_sale_date();
  if (last_sale_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_sale_date_;
    last_sale_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketData_InternalPB::set_allocated_last_sale_date(::std::string* last_sale_date) {
  if (last_sale_date_ != &::google::protobuf::internal::kEmptyString) {
    delete last_sale_date_;
  }
  if (last_sale_date) {
    set_has_last_sale_date();
    last_sale_date_ = last_sale_date;
  } else {
    clear_has_last_sale_date();
    last_sale_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MarketList_InternalPB

// repeated .OTDB.MarketData_InternalPB market_data = 1;
inline int MarketList_InternalPB::market_data_size() const {
  return market_data_.size();
}
inline void MarketList_InternalPB::clear_market_data() {
  market_data_.Clear();
}
inline const ::OTDB::MarketData_InternalPB& MarketList_InternalPB::market_data(int index) const {
  return market_data_.Get(index);
}
inline ::OTDB::MarketData_InternalPB* MarketList_InternalPB::mutable_market_data(int index) {
  return market_data_.Mutable(index);
}
inline ::OTDB::MarketData_InternalPB* MarketList_InternalPB::add_market_data() {
  return market_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OTDB::MarketData_InternalPB >&
MarketList_InternalPB::market_data() const {
  return market_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::OTDB::MarketData_InternalPB >*
MarketList_InternalPB::mutable_market_data() {
  return &market_data_;
}

// -------------------------------------------------------------------

// OfferDataMarket_InternalPB

// optional string gui_label = 1;
inline bool OfferDataMarket_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferDataMarket_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferDataMarket_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferDataMarket_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& OfferDataMarket_InternalPB::gui_label() const {
  return *gui_label_;
}
inline void OfferDataMarket_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataMarket_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  return gui_label_;
}
inline ::std::string* OfferDataMarket_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataMarket_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transaction_id = 2;
inline bool OfferDataMarket_InternalPB::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfferDataMarket_InternalPB::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfferDataMarket_InternalPB::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfferDataMarket_InternalPB::clear_transaction_id() {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    transaction_id_->clear();
  }
  clear_has_transaction_id();
}
inline const ::std::string& OfferDataMarket_InternalPB::transaction_id() const {
  return *transaction_id_;
}
inline void OfferDataMarket_InternalPB::set_transaction_id(const ::std::string& value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_transaction_id(const char* value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_transaction_id(const char* value, size_t size) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataMarket_InternalPB::mutable_transaction_id() {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  return transaction_id_;
}
inline ::std::string* OfferDataMarket_InternalPB::release_transaction_id() {
  clear_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transaction_id_;
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataMarket_InternalPB::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    delete transaction_id_;
  }
  if (transaction_id) {
    set_has_transaction_id();
    transaction_id_ = transaction_id;
  } else {
    clear_has_transaction_id();
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string price_per_scale = 3;
inline bool OfferDataMarket_InternalPB::has_price_per_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfferDataMarket_InternalPB::set_has_price_per_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfferDataMarket_InternalPB::clear_has_price_per_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfferDataMarket_InternalPB::clear_price_per_scale() {
  if (price_per_scale_ != &::google::protobuf::internal::kEmptyString) {
    price_per_scale_->clear();
  }
  clear_has_price_per_scale();
}
inline const ::std::string& OfferDataMarket_InternalPB::price_per_scale() const {
  return *price_per_scale_;
}
inline void OfferDataMarket_InternalPB::set_price_per_scale(const ::std::string& value) {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  price_per_scale_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_price_per_scale(const char* value) {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  price_per_scale_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_price_per_scale(const char* value, size_t size) {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  price_per_scale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataMarket_InternalPB::mutable_price_per_scale() {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  return price_per_scale_;
}
inline ::std::string* OfferDataMarket_InternalPB::release_price_per_scale() {
  clear_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_per_scale_;
    price_per_scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataMarket_InternalPB::set_allocated_price_per_scale(::std::string* price_per_scale) {
  if (price_per_scale_ != &::google::protobuf::internal::kEmptyString) {
    delete price_per_scale_;
  }
  if (price_per_scale) {
    set_has_price_per_scale();
    price_per_scale_ = price_per_scale;
  } else {
    clear_has_price_per_scale();
    price_per_scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string available_assets = 4;
inline bool OfferDataMarket_InternalPB::has_available_assets() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfferDataMarket_InternalPB::set_has_available_assets() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfferDataMarket_InternalPB::clear_has_available_assets() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfferDataMarket_InternalPB::clear_available_assets() {
  if (available_assets_ != &::google::protobuf::internal::kEmptyString) {
    available_assets_->clear();
  }
  clear_has_available_assets();
}
inline const ::std::string& OfferDataMarket_InternalPB::available_assets() const {
  return *available_assets_;
}
inline void OfferDataMarket_InternalPB::set_available_assets(const ::std::string& value) {
  set_has_available_assets();
  if (available_assets_ == &::google::protobuf::internal::kEmptyString) {
    available_assets_ = new ::std::string;
  }
  available_assets_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_available_assets(const char* value) {
  set_has_available_assets();
  if (available_assets_ == &::google::protobuf::internal::kEmptyString) {
    available_assets_ = new ::std::string;
  }
  available_assets_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_available_assets(const char* value, size_t size) {
  set_has_available_assets();
  if (available_assets_ == &::google::protobuf::internal::kEmptyString) {
    available_assets_ = new ::std::string;
  }
  available_assets_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataMarket_InternalPB::mutable_available_assets() {
  set_has_available_assets();
  if (available_assets_ == &::google::protobuf::internal::kEmptyString) {
    available_assets_ = new ::std::string;
  }
  return available_assets_;
}
inline ::std::string* OfferDataMarket_InternalPB::release_available_assets() {
  clear_has_available_assets();
  if (available_assets_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = available_assets_;
    available_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataMarket_InternalPB::set_allocated_available_assets(::std::string* available_assets) {
  if (available_assets_ != &::google::protobuf::internal::kEmptyString) {
    delete available_assets_;
  }
  if (available_assets) {
    set_has_available_assets();
    available_assets_ = available_assets;
  } else {
    clear_has_available_assets();
    available_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string minimum_increment = 5;
inline bool OfferDataMarket_InternalPB::has_minimum_increment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OfferDataMarket_InternalPB::set_has_minimum_increment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OfferDataMarket_InternalPB::clear_has_minimum_increment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OfferDataMarket_InternalPB::clear_minimum_increment() {
  if (minimum_increment_ != &::google::protobuf::internal::kEmptyString) {
    minimum_increment_->clear();
  }
  clear_has_minimum_increment();
}
inline const ::std::string& OfferDataMarket_InternalPB::minimum_increment() const {
  return *minimum_increment_;
}
inline void OfferDataMarket_InternalPB::set_minimum_increment(const ::std::string& value) {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  minimum_increment_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_minimum_increment(const char* value) {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  minimum_increment_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_minimum_increment(const char* value, size_t size) {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  minimum_increment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataMarket_InternalPB::mutable_minimum_increment() {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  return minimum_increment_;
}
inline ::std::string* OfferDataMarket_InternalPB::release_minimum_increment() {
  clear_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = minimum_increment_;
    minimum_increment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataMarket_InternalPB::set_allocated_minimum_increment(::std::string* minimum_increment) {
  if (minimum_increment_ != &::google::protobuf::internal::kEmptyString) {
    delete minimum_increment_;
  }
  if (minimum_increment) {
    set_has_minimum_increment();
    minimum_increment_ = minimum_increment;
  } else {
    clear_has_minimum_increment();
    minimum_increment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date = 6;
inline bool OfferDataMarket_InternalPB::has_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OfferDataMarket_InternalPB::set_has_date() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OfferDataMarket_InternalPB::clear_has_date() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OfferDataMarket_InternalPB::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& OfferDataMarket_InternalPB::date() const {
  return *date_;
}
inline void OfferDataMarket_InternalPB::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void OfferDataMarket_InternalPB::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataMarket_InternalPB::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* OfferDataMarket_InternalPB::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataMarket_InternalPB::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OfferListMarket_InternalPB

// repeated .OTDB.OfferDataMarket_InternalPB bids = 1;
inline int OfferListMarket_InternalPB::bids_size() const {
  return bids_.size();
}
inline void OfferListMarket_InternalPB::clear_bids() {
  bids_.Clear();
}
inline const ::OTDB::OfferDataMarket_InternalPB& OfferListMarket_InternalPB::bids(int index) const {
  return bids_.Get(index);
}
inline ::OTDB::OfferDataMarket_InternalPB* OfferListMarket_InternalPB::mutable_bids(int index) {
  return bids_.Mutable(index);
}
inline ::OTDB::OfferDataMarket_InternalPB* OfferListMarket_InternalPB::add_bids() {
  return bids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >&
OfferListMarket_InternalPB::bids() const {
  return bids_;
}
inline ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >*
OfferListMarket_InternalPB::mutable_bids() {
  return &bids_;
}

// repeated .OTDB.OfferDataMarket_InternalPB asks = 2;
inline int OfferListMarket_InternalPB::asks_size() const {
  return asks_.size();
}
inline void OfferListMarket_InternalPB::clear_asks() {
  asks_.Clear();
}
inline const ::OTDB::OfferDataMarket_InternalPB& OfferListMarket_InternalPB::asks(int index) const {
  return asks_.Get(index);
}
inline ::OTDB::OfferDataMarket_InternalPB* OfferListMarket_InternalPB::mutable_asks(int index) {
  return asks_.Mutable(index);
}
inline ::OTDB::OfferDataMarket_InternalPB* OfferListMarket_InternalPB::add_asks() {
  return asks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >&
OfferListMarket_InternalPB::asks() const {
  return asks_;
}
inline ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataMarket_InternalPB >*
OfferListMarket_InternalPB::mutable_asks() {
  return &asks_;
}

// -------------------------------------------------------------------

// TradeDataMarket_InternalPB

// optional string gui_label = 1;
inline bool TradeDataMarket_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeDataMarket_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeDataMarket_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeDataMarket_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& TradeDataMarket_InternalPB::gui_label() const {
  return *gui_label_;
}
inline void TradeDataMarket_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataMarket_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  return gui_label_;
}
inline ::std::string* TradeDataMarket_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataMarket_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transaction_id = 2;
inline bool TradeDataMarket_InternalPB::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeDataMarket_InternalPB::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeDataMarket_InternalPB::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeDataMarket_InternalPB::clear_transaction_id() {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    transaction_id_->clear();
  }
  clear_has_transaction_id();
}
inline const ::std::string& TradeDataMarket_InternalPB::transaction_id() const {
  return *transaction_id_;
}
inline void TradeDataMarket_InternalPB::set_transaction_id(const ::std::string& value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_transaction_id(const char* value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_transaction_id(const char* value, size_t size) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataMarket_InternalPB::mutable_transaction_id() {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  return transaction_id_;
}
inline ::std::string* TradeDataMarket_InternalPB::release_transaction_id() {
  clear_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transaction_id_;
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataMarket_InternalPB::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    delete transaction_id_;
  }
  if (transaction_id) {
    set_has_transaction_id();
    transaction_id_ = transaction_id;
  } else {
    clear_has_transaction_id();
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date = 3;
inline bool TradeDataMarket_InternalPB::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeDataMarket_InternalPB::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeDataMarket_InternalPB::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeDataMarket_InternalPB::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& TradeDataMarket_InternalPB::date() const {
  return *date_;
}
inline void TradeDataMarket_InternalPB::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataMarket_InternalPB::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* TradeDataMarket_InternalPB::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataMarket_InternalPB::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string price = 4;
inline bool TradeDataMarket_InternalPB::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeDataMarket_InternalPB::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeDataMarket_InternalPB::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeDataMarket_InternalPB::clear_price() {
  if (price_ != &::google::protobuf::internal::kEmptyString) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& TradeDataMarket_InternalPB::price() const {
  return *price_;
}
inline void TradeDataMarket_InternalPB::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataMarket_InternalPB::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  return price_;
}
inline ::std::string* TradeDataMarket_InternalPB::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataMarket_InternalPB::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::kEmptyString) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount_sold = 5;
inline bool TradeDataMarket_InternalPB::has_amount_sold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TradeDataMarket_InternalPB::set_has_amount_sold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TradeDataMarket_InternalPB::clear_has_amount_sold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TradeDataMarket_InternalPB::clear_amount_sold() {
  if (amount_sold_ != &::google::protobuf::internal::kEmptyString) {
    amount_sold_->clear();
  }
  clear_has_amount_sold();
}
inline const ::std::string& TradeDataMarket_InternalPB::amount_sold() const {
  return *amount_sold_;
}
inline void TradeDataMarket_InternalPB::set_amount_sold(const ::std::string& value) {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  amount_sold_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_amount_sold(const char* value) {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  amount_sold_->assign(value);
}
inline void TradeDataMarket_InternalPB::set_amount_sold(const char* value, size_t size) {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  amount_sold_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataMarket_InternalPB::mutable_amount_sold() {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  return amount_sold_;
}
inline ::std::string* TradeDataMarket_InternalPB::release_amount_sold() {
  clear_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_sold_;
    amount_sold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataMarket_InternalPB::set_allocated_amount_sold(::std::string* amount_sold) {
  if (amount_sold_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_sold_;
  }
  if (amount_sold) {
    set_has_amount_sold();
    amount_sold_ = amount_sold;
  } else {
    clear_has_amount_sold();
    amount_sold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TradeListMarket_InternalPB

// repeated .OTDB.TradeDataMarket_InternalPB trades = 1;
inline int TradeListMarket_InternalPB::trades_size() const {
  return trades_.size();
}
inline void TradeListMarket_InternalPB::clear_trades() {
  trades_.Clear();
}
inline const ::OTDB::TradeDataMarket_InternalPB& TradeListMarket_InternalPB::trades(int index) const {
  return trades_.Get(index);
}
inline ::OTDB::TradeDataMarket_InternalPB* TradeListMarket_InternalPB::mutable_trades(int index) {
  return trades_.Mutable(index);
}
inline ::OTDB::TradeDataMarket_InternalPB* TradeListMarket_InternalPB::add_trades() {
  return trades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataMarket_InternalPB >&
TradeListMarket_InternalPB::trades() const {
  return trades_;
}
inline ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataMarket_InternalPB >*
TradeListMarket_InternalPB::mutable_trades() {
  return &trades_;
}

// -------------------------------------------------------------------

// OfferDataNym_InternalPB

// optional string gui_label = 1;
inline bool OfferDataNym_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfferDataNym_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfferDataNym_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& OfferDataNym_InternalPB::gui_label() const {
  return *gui_label_;
}
inline void OfferDataNym_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void OfferDataNym_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void OfferDataNym_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  return gui_label_;
}
inline ::std::string* OfferDataNym_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string valid_from = 2;
inline bool OfferDataNym_InternalPB::has_valid_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_valid_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfferDataNym_InternalPB::clear_has_valid_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfferDataNym_InternalPB::clear_valid_from() {
  if (valid_from_ != &::google::protobuf::internal::kEmptyString) {
    valid_from_->clear();
  }
  clear_has_valid_from();
}
inline const ::std::string& OfferDataNym_InternalPB::valid_from() const {
  return *valid_from_;
}
inline void OfferDataNym_InternalPB::set_valid_from(const ::std::string& value) {
  set_has_valid_from();
  if (valid_from_ == &::google::protobuf::internal::kEmptyString) {
    valid_from_ = new ::std::string;
  }
  valid_from_->assign(value);
}
inline void OfferDataNym_InternalPB::set_valid_from(const char* value) {
  set_has_valid_from();
  if (valid_from_ == &::google::protobuf::internal::kEmptyString) {
    valid_from_ = new ::std::string;
  }
  valid_from_->assign(value);
}
inline void OfferDataNym_InternalPB::set_valid_from(const char* value, size_t size) {
  set_has_valid_from();
  if (valid_from_ == &::google::protobuf::internal::kEmptyString) {
    valid_from_ = new ::std::string;
  }
  valid_from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_valid_from() {
  set_has_valid_from();
  if (valid_from_ == &::google::protobuf::internal::kEmptyString) {
    valid_from_ = new ::std::string;
  }
  return valid_from_;
}
inline ::std::string* OfferDataNym_InternalPB::release_valid_from() {
  clear_has_valid_from();
  if (valid_from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_from_;
    valid_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_valid_from(::std::string* valid_from) {
  if (valid_from_ != &::google::protobuf::internal::kEmptyString) {
    delete valid_from_;
  }
  if (valid_from) {
    set_has_valid_from();
    valid_from_ = valid_from;
  } else {
    clear_has_valid_from();
    valid_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string valid_to = 3;
inline bool OfferDataNym_InternalPB::has_valid_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_valid_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfferDataNym_InternalPB::clear_has_valid_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfferDataNym_InternalPB::clear_valid_to() {
  if (valid_to_ != &::google::protobuf::internal::kEmptyString) {
    valid_to_->clear();
  }
  clear_has_valid_to();
}
inline const ::std::string& OfferDataNym_InternalPB::valid_to() const {
  return *valid_to_;
}
inline void OfferDataNym_InternalPB::set_valid_to(const ::std::string& value) {
  set_has_valid_to();
  if (valid_to_ == &::google::protobuf::internal::kEmptyString) {
    valid_to_ = new ::std::string;
  }
  valid_to_->assign(value);
}
inline void OfferDataNym_InternalPB::set_valid_to(const char* value) {
  set_has_valid_to();
  if (valid_to_ == &::google::protobuf::internal::kEmptyString) {
    valid_to_ = new ::std::string;
  }
  valid_to_->assign(value);
}
inline void OfferDataNym_InternalPB::set_valid_to(const char* value, size_t size) {
  set_has_valid_to();
  if (valid_to_ == &::google::protobuf::internal::kEmptyString) {
    valid_to_ = new ::std::string;
  }
  valid_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_valid_to() {
  set_has_valid_to();
  if (valid_to_ == &::google::protobuf::internal::kEmptyString) {
    valid_to_ = new ::std::string;
  }
  return valid_to_;
}
inline ::std::string* OfferDataNym_InternalPB::release_valid_to() {
  clear_has_valid_to();
  if (valid_to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = valid_to_;
    valid_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_valid_to(::std::string* valid_to) {
  if (valid_to_ != &::google::protobuf::internal::kEmptyString) {
    delete valid_to_;
  }
  if (valid_to) {
    set_has_valid_to();
    valid_to_ = valid_to;
  } else {
    clear_has_valid_to();
    valid_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_id = 4;
inline bool OfferDataNym_InternalPB::has_server_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_server_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfferDataNym_InternalPB::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfferDataNym_InternalPB::clear_server_id() {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    server_id_->clear();
  }
  clear_has_server_id();
}
inline const ::std::string& OfferDataNym_InternalPB::server_id() const {
  return *server_id_;
}
inline void OfferDataNym_InternalPB::set_server_id(const ::std::string& value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_server_id(const char* value) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  server_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_server_id() {
  set_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    server_id_ = new ::std::string;
  }
  return server_id_;
}
inline ::std::string* OfferDataNym_InternalPB::release_server_id() {
  clear_has_server_id();
  if (server_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_id_;
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_server_id(::std::string* server_id) {
  if (server_id_ != &::google::protobuf::internal::kEmptyString) {
    delete server_id_;
  }
  if (server_id) {
    set_has_server_id();
    server_id_ = server_id;
  } else {
    clear_has_server_id();
    server_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string asset_type_id = 5;
inline bool OfferDataNym_InternalPB::has_asset_type_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_asset_type_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OfferDataNym_InternalPB::clear_has_asset_type_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OfferDataNym_InternalPB::clear_asset_type_id() {
  if (asset_type_id_ != &::google::protobuf::internal::kEmptyString) {
    asset_type_id_->clear();
  }
  clear_has_asset_type_id();
}
inline const ::std::string& OfferDataNym_InternalPB::asset_type_id() const {
  return *asset_type_id_;
}
inline void OfferDataNym_InternalPB::set_asset_type_id(const ::std::string& value) {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  asset_type_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_asset_type_id(const char* value) {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  asset_type_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_asset_type_id(const char* value, size_t size) {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  asset_type_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_asset_type_id() {
  set_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_type_id_ = new ::std::string;
  }
  return asset_type_id_;
}
inline ::std::string* OfferDataNym_InternalPB::release_asset_type_id() {
  clear_has_asset_type_id();
  if (asset_type_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asset_type_id_;
    asset_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_asset_type_id(::std::string* asset_type_id) {
  if (asset_type_id_ != &::google::protobuf::internal::kEmptyString) {
    delete asset_type_id_;
  }
  if (asset_type_id) {
    set_has_asset_type_id();
    asset_type_id_ = asset_type_id;
  } else {
    clear_has_asset_type_id();
    asset_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string asset_acct_id = 6;
inline bool OfferDataNym_InternalPB::has_asset_acct_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_asset_acct_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OfferDataNym_InternalPB::clear_has_asset_acct_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OfferDataNym_InternalPB::clear_asset_acct_id() {
  if (asset_acct_id_ != &::google::protobuf::internal::kEmptyString) {
    asset_acct_id_->clear();
  }
  clear_has_asset_acct_id();
}
inline const ::std::string& OfferDataNym_InternalPB::asset_acct_id() const {
  return *asset_acct_id_;
}
inline void OfferDataNym_InternalPB::set_asset_acct_id(const ::std::string& value) {
  set_has_asset_acct_id();
  if (asset_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_acct_id_ = new ::std::string;
  }
  asset_acct_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_asset_acct_id(const char* value) {
  set_has_asset_acct_id();
  if (asset_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_acct_id_ = new ::std::string;
  }
  asset_acct_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_asset_acct_id(const char* value, size_t size) {
  set_has_asset_acct_id();
  if (asset_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_acct_id_ = new ::std::string;
  }
  asset_acct_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_asset_acct_id() {
  set_has_asset_acct_id();
  if (asset_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_acct_id_ = new ::std::string;
  }
  return asset_acct_id_;
}
inline ::std::string* OfferDataNym_InternalPB::release_asset_acct_id() {
  clear_has_asset_acct_id();
  if (asset_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asset_acct_id_;
    asset_acct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_asset_acct_id(::std::string* asset_acct_id) {
  if (asset_acct_id_ != &::google::protobuf::internal::kEmptyString) {
    delete asset_acct_id_;
  }
  if (asset_acct_id) {
    set_has_asset_acct_id();
    asset_acct_id_ = asset_acct_id;
  } else {
    clear_has_asset_acct_id();
    asset_acct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency_type_id = 7;
inline bool OfferDataNym_InternalPB::has_currency_type_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_currency_type_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OfferDataNym_InternalPB::clear_has_currency_type_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OfferDataNym_InternalPB::clear_currency_type_id() {
  if (currency_type_id_ != &::google::protobuf::internal::kEmptyString) {
    currency_type_id_->clear();
  }
  clear_has_currency_type_id();
}
inline const ::std::string& OfferDataNym_InternalPB::currency_type_id() const {
  return *currency_type_id_;
}
inline void OfferDataNym_InternalPB::set_currency_type_id(const ::std::string& value) {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  currency_type_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_currency_type_id(const char* value) {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  currency_type_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_currency_type_id(const char* value, size_t size) {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  currency_type_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_currency_type_id() {
  set_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_type_id_ = new ::std::string;
  }
  return currency_type_id_;
}
inline ::std::string* OfferDataNym_InternalPB::release_currency_type_id() {
  clear_has_currency_type_id();
  if (currency_type_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_type_id_;
    currency_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_currency_type_id(::std::string* currency_type_id) {
  if (currency_type_id_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_type_id_;
  }
  if (currency_type_id) {
    set_has_currency_type_id();
    currency_type_id_ = currency_type_id;
  } else {
    clear_has_currency_type_id();
    currency_type_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency_acct_id = 8;
inline bool OfferDataNym_InternalPB::has_currency_acct_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_currency_acct_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OfferDataNym_InternalPB::clear_has_currency_acct_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OfferDataNym_InternalPB::clear_currency_acct_id() {
  if (currency_acct_id_ != &::google::protobuf::internal::kEmptyString) {
    currency_acct_id_->clear();
  }
  clear_has_currency_acct_id();
}
inline const ::std::string& OfferDataNym_InternalPB::currency_acct_id() const {
  return *currency_acct_id_;
}
inline void OfferDataNym_InternalPB::set_currency_acct_id(const ::std::string& value) {
  set_has_currency_acct_id();
  if (currency_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_acct_id_ = new ::std::string;
  }
  currency_acct_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_currency_acct_id(const char* value) {
  set_has_currency_acct_id();
  if (currency_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_acct_id_ = new ::std::string;
  }
  currency_acct_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_currency_acct_id(const char* value, size_t size) {
  set_has_currency_acct_id();
  if (currency_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_acct_id_ = new ::std::string;
  }
  currency_acct_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_currency_acct_id() {
  set_has_currency_acct_id();
  if (currency_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_acct_id_ = new ::std::string;
  }
  return currency_acct_id_;
}
inline ::std::string* OfferDataNym_InternalPB::release_currency_acct_id() {
  clear_has_currency_acct_id();
  if (currency_acct_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_acct_id_;
    currency_acct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_currency_acct_id(::std::string* currency_acct_id) {
  if (currency_acct_id_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_acct_id_;
  }
  if (currency_acct_id) {
    set_has_currency_acct_id();
    currency_acct_id_ = currency_acct_id;
  } else {
    clear_has_currency_acct_id();
    currency_acct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool selling = 9;
inline bool OfferDataNym_InternalPB::has_selling() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_selling() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OfferDataNym_InternalPB::clear_has_selling() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OfferDataNym_InternalPB::clear_selling() {
  selling_ = false;
  clear_has_selling();
}
inline bool OfferDataNym_InternalPB::selling() const {
  return selling_;
}
inline void OfferDataNym_InternalPB::set_selling(bool value) {
  set_has_selling();
  selling_ = value;
}

// optional string scale = 10;
inline bool OfferDataNym_InternalPB::has_scale() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_scale() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OfferDataNym_InternalPB::clear_has_scale() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OfferDataNym_InternalPB::clear_scale() {
  if (scale_ != &::google::protobuf::internal::kEmptyString) {
    scale_->clear();
  }
  clear_has_scale();
}
inline const ::std::string& OfferDataNym_InternalPB::scale() const {
  return *scale_;
}
inline void OfferDataNym_InternalPB::set_scale(const ::std::string& value) {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  scale_->assign(value);
}
inline void OfferDataNym_InternalPB::set_scale(const char* value) {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  scale_->assign(value);
}
inline void OfferDataNym_InternalPB::set_scale(const char* value, size_t size) {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  scale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_scale() {
  set_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    scale_ = new ::std::string;
  }
  return scale_;
}
inline ::std::string* OfferDataNym_InternalPB::release_scale() {
  clear_has_scale();
  if (scale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scale_;
    scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_scale(::std::string* scale) {
  if (scale_ != &::google::protobuf::internal::kEmptyString) {
    delete scale_;
  }
  if (scale) {
    set_has_scale();
    scale_ = scale;
  } else {
    clear_has_scale();
    scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string price_per_scale = 11;
inline bool OfferDataNym_InternalPB::has_price_per_scale() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_price_per_scale() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OfferDataNym_InternalPB::clear_has_price_per_scale() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OfferDataNym_InternalPB::clear_price_per_scale() {
  if (price_per_scale_ != &::google::protobuf::internal::kEmptyString) {
    price_per_scale_->clear();
  }
  clear_has_price_per_scale();
}
inline const ::std::string& OfferDataNym_InternalPB::price_per_scale() const {
  return *price_per_scale_;
}
inline void OfferDataNym_InternalPB::set_price_per_scale(const ::std::string& value) {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  price_per_scale_->assign(value);
}
inline void OfferDataNym_InternalPB::set_price_per_scale(const char* value) {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  price_per_scale_->assign(value);
}
inline void OfferDataNym_InternalPB::set_price_per_scale(const char* value, size_t size) {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  price_per_scale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_price_per_scale() {
  set_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    price_per_scale_ = new ::std::string;
  }
  return price_per_scale_;
}
inline ::std::string* OfferDataNym_InternalPB::release_price_per_scale() {
  clear_has_price_per_scale();
  if (price_per_scale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_per_scale_;
    price_per_scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_price_per_scale(::std::string* price_per_scale) {
  if (price_per_scale_ != &::google::protobuf::internal::kEmptyString) {
    delete price_per_scale_;
  }
  if (price_per_scale) {
    set_has_price_per_scale();
    price_per_scale_ = price_per_scale;
  } else {
    clear_has_price_per_scale();
    price_per_scale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transaction_id = 12;
inline bool OfferDataNym_InternalPB::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OfferDataNym_InternalPB::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OfferDataNym_InternalPB::clear_transaction_id() {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    transaction_id_->clear();
  }
  clear_has_transaction_id();
}
inline const ::std::string& OfferDataNym_InternalPB::transaction_id() const {
  return *transaction_id_;
}
inline void OfferDataNym_InternalPB::set_transaction_id(const ::std::string& value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_transaction_id(const char* value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void OfferDataNym_InternalPB::set_transaction_id(const char* value, size_t size) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_transaction_id() {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  return transaction_id_;
}
inline ::std::string* OfferDataNym_InternalPB::release_transaction_id() {
  clear_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transaction_id_;
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    delete transaction_id_;
  }
  if (transaction_id) {
    set_has_transaction_id();
    transaction_id_ = transaction_id;
  } else {
    clear_has_transaction_id();
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string total_assets = 13;
inline bool OfferDataNym_InternalPB::has_total_assets() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_total_assets() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OfferDataNym_InternalPB::clear_has_total_assets() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OfferDataNym_InternalPB::clear_total_assets() {
  if (total_assets_ != &::google::protobuf::internal::kEmptyString) {
    total_assets_->clear();
  }
  clear_has_total_assets();
}
inline const ::std::string& OfferDataNym_InternalPB::total_assets() const {
  return *total_assets_;
}
inline void OfferDataNym_InternalPB::set_total_assets(const ::std::string& value) {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  total_assets_->assign(value);
}
inline void OfferDataNym_InternalPB::set_total_assets(const char* value) {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  total_assets_->assign(value);
}
inline void OfferDataNym_InternalPB::set_total_assets(const char* value, size_t size) {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  total_assets_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_total_assets() {
  set_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    total_assets_ = new ::std::string;
  }
  return total_assets_;
}
inline ::std::string* OfferDataNym_InternalPB::release_total_assets() {
  clear_has_total_assets();
  if (total_assets_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_assets_;
    total_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_total_assets(::std::string* total_assets) {
  if (total_assets_ != &::google::protobuf::internal::kEmptyString) {
    delete total_assets_;
  }
  if (total_assets) {
    set_has_total_assets();
    total_assets_ = total_assets;
  } else {
    clear_has_total_assets();
    total_assets_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string finished_so_far = 14;
inline bool OfferDataNym_InternalPB::has_finished_so_far() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_finished_so_far() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OfferDataNym_InternalPB::clear_has_finished_so_far() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OfferDataNym_InternalPB::clear_finished_so_far() {
  if (finished_so_far_ != &::google::protobuf::internal::kEmptyString) {
    finished_so_far_->clear();
  }
  clear_has_finished_so_far();
}
inline const ::std::string& OfferDataNym_InternalPB::finished_so_far() const {
  return *finished_so_far_;
}
inline void OfferDataNym_InternalPB::set_finished_so_far(const ::std::string& value) {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  finished_so_far_->assign(value);
}
inline void OfferDataNym_InternalPB::set_finished_so_far(const char* value) {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  finished_so_far_->assign(value);
}
inline void OfferDataNym_InternalPB::set_finished_so_far(const char* value, size_t size) {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  finished_so_far_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_finished_so_far() {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  return finished_so_far_;
}
inline ::std::string* OfferDataNym_InternalPB::release_finished_so_far() {
  clear_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finished_so_far_;
    finished_so_far_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_finished_so_far(::std::string* finished_so_far) {
  if (finished_so_far_ != &::google::protobuf::internal::kEmptyString) {
    delete finished_so_far_;
  }
  if (finished_so_far) {
    set_has_finished_so_far();
    finished_so_far_ = finished_so_far;
  } else {
    clear_has_finished_so_far();
    finished_so_far_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string minimum_increment = 15;
inline bool OfferDataNym_InternalPB::has_minimum_increment() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_minimum_increment() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OfferDataNym_InternalPB::clear_has_minimum_increment() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OfferDataNym_InternalPB::clear_minimum_increment() {
  if (minimum_increment_ != &::google::protobuf::internal::kEmptyString) {
    minimum_increment_->clear();
  }
  clear_has_minimum_increment();
}
inline const ::std::string& OfferDataNym_InternalPB::minimum_increment() const {
  return *minimum_increment_;
}
inline void OfferDataNym_InternalPB::set_minimum_increment(const ::std::string& value) {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  minimum_increment_->assign(value);
}
inline void OfferDataNym_InternalPB::set_minimum_increment(const char* value) {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  minimum_increment_->assign(value);
}
inline void OfferDataNym_InternalPB::set_minimum_increment(const char* value, size_t size) {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  minimum_increment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_minimum_increment() {
  set_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    minimum_increment_ = new ::std::string;
  }
  return minimum_increment_;
}
inline ::std::string* OfferDataNym_InternalPB::release_minimum_increment() {
  clear_has_minimum_increment();
  if (minimum_increment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = minimum_increment_;
    minimum_increment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_minimum_increment(::std::string* minimum_increment) {
  if (minimum_increment_ != &::google::protobuf::internal::kEmptyString) {
    delete minimum_increment_;
  }
  if (minimum_increment) {
    set_has_minimum_increment();
    minimum_increment_ = minimum_increment;
  } else {
    clear_has_minimum_increment();
    minimum_increment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string stop_sign = 16;
inline bool OfferDataNym_InternalPB::has_stop_sign() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_stop_sign() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OfferDataNym_InternalPB::clear_has_stop_sign() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OfferDataNym_InternalPB::clear_stop_sign() {
  if (stop_sign_ != &::google::protobuf::internal::kEmptyString) {
    stop_sign_->clear();
  }
  clear_has_stop_sign();
}
inline const ::std::string& OfferDataNym_InternalPB::stop_sign() const {
  return *stop_sign_;
}
inline void OfferDataNym_InternalPB::set_stop_sign(const ::std::string& value) {
  set_has_stop_sign();
  if (stop_sign_ == &::google::protobuf::internal::kEmptyString) {
    stop_sign_ = new ::std::string;
  }
  stop_sign_->assign(value);
}
inline void OfferDataNym_InternalPB::set_stop_sign(const char* value) {
  set_has_stop_sign();
  if (stop_sign_ == &::google::protobuf::internal::kEmptyString) {
    stop_sign_ = new ::std::string;
  }
  stop_sign_->assign(value);
}
inline void OfferDataNym_InternalPB::set_stop_sign(const char* value, size_t size) {
  set_has_stop_sign();
  if (stop_sign_ == &::google::protobuf::internal::kEmptyString) {
    stop_sign_ = new ::std::string;
  }
  stop_sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_stop_sign() {
  set_has_stop_sign();
  if (stop_sign_ == &::google::protobuf::internal::kEmptyString) {
    stop_sign_ = new ::std::string;
  }
  return stop_sign_;
}
inline ::std::string* OfferDataNym_InternalPB::release_stop_sign() {
  clear_has_stop_sign();
  if (stop_sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_sign_;
    stop_sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_stop_sign(::std::string* stop_sign) {
  if (stop_sign_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_sign_;
  }
  if (stop_sign) {
    set_has_stop_sign();
    stop_sign_ = stop_sign;
  } else {
    clear_has_stop_sign();
    stop_sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string stop_price = 17;
inline bool OfferDataNym_InternalPB::has_stop_price() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_stop_price() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OfferDataNym_InternalPB::clear_has_stop_price() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OfferDataNym_InternalPB::clear_stop_price() {
  if (stop_price_ != &::google::protobuf::internal::kEmptyString) {
    stop_price_->clear();
  }
  clear_has_stop_price();
}
inline const ::std::string& OfferDataNym_InternalPB::stop_price() const {
  return *stop_price_;
}
inline void OfferDataNym_InternalPB::set_stop_price(const ::std::string& value) {
  set_has_stop_price();
  if (stop_price_ == &::google::protobuf::internal::kEmptyString) {
    stop_price_ = new ::std::string;
  }
  stop_price_->assign(value);
}
inline void OfferDataNym_InternalPB::set_stop_price(const char* value) {
  set_has_stop_price();
  if (stop_price_ == &::google::protobuf::internal::kEmptyString) {
    stop_price_ = new ::std::string;
  }
  stop_price_->assign(value);
}
inline void OfferDataNym_InternalPB::set_stop_price(const char* value, size_t size) {
  set_has_stop_price();
  if (stop_price_ == &::google::protobuf::internal::kEmptyString) {
    stop_price_ = new ::std::string;
  }
  stop_price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_stop_price() {
  set_has_stop_price();
  if (stop_price_ == &::google::protobuf::internal::kEmptyString) {
    stop_price_ = new ::std::string;
  }
  return stop_price_;
}
inline ::std::string* OfferDataNym_InternalPB::release_stop_price() {
  clear_has_stop_price();
  if (stop_price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_price_;
    stop_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_stop_price(::std::string* stop_price) {
  if (stop_price_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_price_;
  }
  if (stop_price) {
    set_has_stop_price();
    stop_price_ = stop_price;
  } else {
    clear_has_stop_price();
    stop_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date = 18;
inline bool OfferDataNym_InternalPB::has_date() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OfferDataNym_InternalPB::set_has_date() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OfferDataNym_InternalPB::clear_has_date() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OfferDataNym_InternalPB::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& OfferDataNym_InternalPB::date() const {
  return *date_;
}
inline void OfferDataNym_InternalPB::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void OfferDataNym_InternalPB::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void OfferDataNym_InternalPB::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OfferDataNym_InternalPB::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* OfferDataNym_InternalPB::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OfferDataNym_InternalPB::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OfferListNym_InternalPB

// repeated .OTDB.OfferDataNym_InternalPB offers = 1;
inline int OfferListNym_InternalPB::offers_size() const {
  return offers_.size();
}
inline void OfferListNym_InternalPB::clear_offers() {
  offers_.Clear();
}
inline const ::OTDB::OfferDataNym_InternalPB& OfferListNym_InternalPB::offers(int index) const {
  return offers_.Get(index);
}
inline ::OTDB::OfferDataNym_InternalPB* OfferListNym_InternalPB::mutable_offers(int index) {
  return offers_.Mutable(index);
}
inline ::OTDB::OfferDataNym_InternalPB* OfferListNym_InternalPB::add_offers() {
  return offers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataNym_InternalPB >&
OfferListNym_InternalPB::offers() const {
  return offers_;
}
inline ::google::protobuf::RepeatedPtrField< ::OTDB::OfferDataNym_InternalPB >*
OfferListNym_InternalPB::mutable_offers() {
  return &offers_;
}

// -------------------------------------------------------------------

// TradeDataNym_InternalPB

// optional string gui_label = 1;
inline bool TradeDataNym_InternalPB::has_gui_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_gui_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeDataNym_InternalPB::clear_has_gui_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeDataNym_InternalPB::clear_gui_label() {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    gui_label_->clear();
  }
  clear_has_gui_label();
}
inline const ::std::string& TradeDataNym_InternalPB::gui_label() const {
  return *gui_label_;
}
inline void TradeDataNym_InternalPB::set_gui_label(const ::std::string& value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void TradeDataNym_InternalPB::set_gui_label(const char* value) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(value);
}
inline void TradeDataNym_InternalPB::set_gui_label(const char* value, size_t size) {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  gui_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_gui_label() {
  set_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    gui_label_ = new ::std::string;
  }
  return gui_label_;
}
inline ::std::string* TradeDataNym_InternalPB::release_gui_label() {
  clear_has_gui_label();
  if (gui_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gui_label_;
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_gui_label(::std::string* gui_label) {
  if (gui_label_ != &::google::protobuf::internal::kEmptyString) {
    delete gui_label_;
  }
  if (gui_label) {
    set_has_gui_label();
    gui_label_ = gui_label;
  } else {
    clear_has_gui_label();
    gui_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string completed_count = 2;
inline bool TradeDataNym_InternalPB::has_completed_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_completed_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeDataNym_InternalPB::clear_has_completed_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeDataNym_InternalPB::clear_completed_count() {
  if (completed_count_ != &::google::protobuf::internal::kEmptyString) {
    completed_count_->clear();
  }
  clear_has_completed_count();
}
inline const ::std::string& TradeDataNym_InternalPB::completed_count() const {
  return *completed_count_;
}
inline void TradeDataNym_InternalPB::set_completed_count(const ::std::string& value) {
  set_has_completed_count();
  if (completed_count_ == &::google::protobuf::internal::kEmptyString) {
    completed_count_ = new ::std::string;
  }
  completed_count_->assign(value);
}
inline void TradeDataNym_InternalPB::set_completed_count(const char* value) {
  set_has_completed_count();
  if (completed_count_ == &::google::protobuf::internal::kEmptyString) {
    completed_count_ = new ::std::string;
  }
  completed_count_->assign(value);
}
inline void TradeDataNym_InternalPB::set_completed_count(const char* value, size_t size) {
  set_has_completed_count();
  if (completed_count_ == &::google::protobuf::internal::kEmptyString) {
    completed_count_ = new ::std::string;
  }
  completed_count_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_completed_count() {
  set_has_completed_count();
  if (completed_count_ == &::google::protobuf::internal::kEmptyString) {
    completed_count_ = new ::std::string;
  }
  return completed_count_;
}
inline ::std::string* TradeDataNym_InternalPB::release_completed_count() {
  clear_has_completed_count();
  if (completed_count_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = completed_count_;
    completed_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_completed_count(::std::string* completed_count) {
  if (completed_count_ != &::google::protobuf::internal::kEmptyString) {
    delete completed_count_;
  }
  if (completed_count) {
    set_has_completed_count();
    completed_count_ = completed_count;
  } else {
    clear_has_completed_count();
    completed_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date = 3;
inline bool TradeDataNym_InternalPB::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeDataNym_InternalPB::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeDataNym_InternalPB::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& TradeDataNym_InternalPB::date() const {
  return *date_;
}
inline void TradeDataNym_InternalPB::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void TradeDataNym_InternalPB::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void TradeDataNym_InternalPB::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* TradeDataNym_InternalPB::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string price = 4;
inline bool TradeDataNym_InternalPB::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeDataNym_InternalPB::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeDataNym_InternalPB::clear_price() {
  if (price_ != &::google::protobuf::internal::kEmptyString) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& TradeDataNym_InternalPB::price() const {
  return *price_;
}
inline void TradeDataNym_InternalPB::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void TradeDataNym_InternalPB::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void TradeDataNym_InternalPB::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  return price_;
}
inline ::std::string* TradeDataNym_InternalPB::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_price(::std::string* price) {
  if (price_ != &::google::protobuf::internal::kEmptyString) {
    delete price_;
  }
  if (price) {
    set_has_price();
    price_ = price;
  } else {
    clear_has_price();
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string amount_sold = 5;
inline bool TradeDataNym_InternalPB::has_amount_sold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_amount_sold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TradeDataNym_InternalPB::clear_has_amount_sold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TradeDataNym_InternalPB::clear_amount_sold() {
  if (amount_sold_ != &::google::protobuf::internal::kEmptyString) {
    amount_sold_->clear();
  }
  clear_has_amount_sold();
}
inline const ::std::string& TradeDataNym_InternalPB::amount_sold() const {
  return *amount_sold_;
}
inline void TradeDataNym_InternalPB::set_amount_sold(const ::std::string& value) {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  amount_sold_->assign(value);
}
inline void TradeDataNym_InternalPB::set_amount_sold(const char* value) {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  amount_sold_->assign(value);
}
inline void TradeDataNym_InternalPB::set_amount_sold(const char* value, size_t size) {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  amount_sold_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_amount_sold() {
  set_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    amount_sold_ = new ::std::string;
  }
  return amount_sold_;
}
inline ::std::string* TradeDataNym_InternalPB::release_amount_sold() {
  clear_has_amount_sold();
  if (amount_sold_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = amount_sold_;
    amount_sold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_amount_sold(::std::string* amount_sold) {
  if (amount_sold_ != &::google::protobuf::internal::kEmptyString) {
    delete amount_sold_;
  }
  if (amount_sold) {
    set_has_amount_sold();
    amount_sold_ = amount_sold;
  } else {
    clear_has_amount_sold();
    amount_sold_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transaction_id = 6;
inline bool TradeDataNym_InternalPB::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TradeDataNym_InternalPB::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TradeDataNym_InternalPB::clear_transaction_id() {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    transaction_id_->clear();
  }
  clear_has_transaction_id();
}
inline const ::std::string& TradeDataNym_InternalPB::transaction_id() const {
  return *transaction_id_;
}
inline void TradeDataNym_InternalPB::set_transaction_id(const ::std::string& value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_transaction_id(const char* value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_transaction_id(const char* value, size_t size) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_transaction_id() {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  return transaction_id_;
}
inline ::std::string* TradeDataNym_InternalPB::release_transaction_id() {
  clear_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transaction_id_;
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    delete transaction_id_;
  }
  if (transaction_id) {
    set_has_transaction_id();
    transaction_id_ = transaction_id;
  } else {
    clear_has_transaction_id();
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string updated_id = 7;
inline bool TradeDataNym_InternalPB::has_updated_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_updated_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TradeDataNym_InternalPB::clear_has_updated_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TradeDataNym_InternalPB::clear_updated_id() {
  if (updated_id_ != &::google::protobuf::internal::kEmptyString) {
    updated_id_->clear();
  }
  clear_has_updated_id();
}
inline const ::std::string& TradeDataNym_InternalPB::updated_id() const {
  return *updated_id_;
}
inline void TradeDataNym_InternalPB::set_updated_id(const ::std::string& value) {
  set_has_updated_id();
  if (updated_id_ == &::google::protobuf::internal::kEmptyString) {
    updated_id_ = new ::std::string;
  }
  updated_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_updated_id(const char* value) {
  set_has_updated_id();
  if (updated_id_ == &::google::protobuf::internal::kEmptyString) {
    updated_id_ = new ::std::string;
  }
  updated_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_updated_id(const char* value, size_t size) {
  set_has_updated_id();
  if (updated_id_ == &::google::protobuf::internal::kEmptyString) {
    updated_id_ = new ::std::string;
  }
  updated_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_updated_id() {
  set_has_updated_id();
  if (updated_id_ == &::google::protobuf::internal::kEmptyString) {
    updated_id_ = new ::std::string;
  }
  return updated_id_;
}
inline ::std::string* TradeDataNym_InternalPB::release_updated_id() {
  clear_has_updated_id();
  if (updated_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_id_;
    updated_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_updated_id(::std::string* updated_id) {
  if (updated_id_ != &::google::protobuf::internal::kEmptyString) {
    delete updated_id_;
  }
  if (updated_id) {
    set_has_updated_id();
    updated_id_ = updated_id;
  } else {
    clear_has_updated_id();
    updated_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string offer_price = 8;
inline bool TradeDataNym_InternalPB::has_offer_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_offer_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TradeDataNym_InternalPB::clear_has_offer_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TradeDataNym_InternalPB::clear_offer_price() {
  if (offer_price_ != &::google::protobuf::internal::kEmptyString) {
    offer_price_->clear();
  }
  clear_has_offer_price();
}
inline const ::std::string& TradeDataNym_InternalPB::offer_price() const {
  return *offer_price_;
}
inline void TradeDataNym_InternalPB::set_offer_price(const ::std::string& value) {
  set_has_offer_price();
  if (offer_price_ == &::google::protobuf::internal::kEmptyString) {
    offer_price_ = new ::std::string;
  }
  offer_price_->assign(value);
}
inline void TradeDataNym_InternalPB::set_offer_price(const char* value) {
  set_has_offer_price();
  if (offer_price_ == &::google::protobuf::internal::kEmptyString) {
    offer_price_ = new ::std::string;
  }
  offer_price_->assign(value);
}
inline void TradeDataNym_InternalPB::set_offer_price(const char* value, size_t size) {
  set_has_offer_price();
  if (offer_price_ == &::google::protobuf::internal::kEmptyString) {
    offer_price_ = new ::std::string;
  }
  offer_price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_offer_price() {
  set_has_offer_price();
  if (offer_price_ == &::google::protobuf::internal::kEmptyString) {
    offer_price_ = new ::std::string;
  }
  return offer_price_;
}
inline ::std::string* TradeDataNym_InternalPB::release_offer_price() {
  clear_has_offer_price();
  if (offer_price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = offer_price_;
    offer_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_offer_price(::std::string* offer_price) {
  if (offer_price_ != &::google::protobuf::internal::kEmptyString) {
    delete offer_price_;
  }
  if (offer_price) {
    set_has_offer_price();
    offer_price_ = offer_price;
  } else {
    clear_has_offer_price();
    offer_price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string finished_so_far = 9;
inline bool TradeDataNym_InternalPB::has_finished_so_far() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_finished_so_far() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TradeDataNym_InternalPB::clear_has_finished_so_far() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TradeDataNym_InternalPB::clear_finished_so_far() {
  if (finished_so_far_ != &::google::protobuf::internal::kEmptyString) {
    finished_so_far_->clear();
  }
  clear_has_finished_so_far();
}
inline const ::std::string& TradeDataNym_InternalPB::finished_so_far() const {
  return *finished_so_far_;
}
inline void TradeDataNym_InternalPB::set_finished_so_far(const ::std::string& value) {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  finished_so_far_->assign(value);
}
inline void TradeDataNym_InternalPB::set_finished_so_far(const char* value) {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  finished_so_far_->assign(value);
}
inline void TradeDataNym_InternalPB::set_finished_so_far(const char* value, size_t size) {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  finished_so_far_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_finished_so_far() {
  set_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    finished_so_far_ = new ::std::string;
  }
  return finished_so_far_;
}
inline ::std::string* TradeDataNym_InternalPB::release_finished_so_far() {
  clear_has_finished_so_far();
  if (finished_so_far_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finished_so_far_;
    finished_so_far_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_finished_so_far(::std::string* finished_so_far) {
  if (finished_so_far_ != &::google::protobuf::internal::kEmptyString) {
    delete finished_so_far_;
  }
  if (finished_so_far) {
    set_has_finished_so_far();
    finished_so_far_ = finished_so_far;
  } else {
    clear_has_finished_so_far();
    finished_so_far_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string asset_id = 10;
inline bool TradeDataNym_InternalPB::has_asset_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_asset_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TradeDataNym_InternalPB::clear_has_asset_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TradeDataNym_InternalPB::clear_asset_id() {
  if (asset_id_ != &::google::protobuf::internal::kEmptyString) {
    asset_id_->clear();
  }
  clear_has_asset_id();
}
inline const ::std::string& TradeDataNym_InternalPB::asset_id() const {
  return *asset_id_;
}
inline void TradeDataNym_InternalPB::set_asset_id(const ::std::string& value) {
  set_has_asset_id();
  if (asset_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_id_ = new ::std::string;
  }
  asset_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_asset_id(const char* value) {
  set_has_asset_id();
  if (asset_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_id_ = new ::std::string;
  }
  asset_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_asset_id(const char* value, size_t size) {
  set_has_asset_id();
  if (asset_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_id_ = new ::std::string;
  }
  asset_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_asset_id() {
  set_has_asset_id();
  if (asset_id_ == &::google::protobuf::internal::kEmptyString) {
    asset_id_ = new ::std::string;
  }
  return asset_id_;
}
inline ::std::string* TradeDataNym_InternalPB::release_asset_id() {
  clear_has_asset_id();
  if (asset_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asset_id_;
    asset_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_asset_id(::std::string* asset_id) {
  if (asset_id_ != &::google::protobuf::internal::kEmptyString) {
    delete asset_id_;
  }
  if (asset_id) {
    set_has_asset_id();
    asset_id_ = asset_id;
  } else {
    clear_has_asset_id();
    asset_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency_id = 11;
inline bool TradeDataNym_InternalPB::has_currency_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_currency_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TradeDataNym_InternalPB::clear_has_currency_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TradeDataNym_InternalPB::clear_currency_id() {
  if (currency_id_ != &::google::protobuf::internal::kEmptyString) {
    currency_id_->clear();
  }
  clear_has_currency_id();
}
inline const ::std::string& TradeDataNym_InternalPB::currency_id() const {
  return *currency_id_;
}
inline void TradeDataNym_InternalPB::set_currency_id(const ::std::string& value) {
  set_has_currency_id();
  if (currency_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_id_ = new ::std::string;
  }
  currency_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_currency_id(const char* value) {
  set_has_currency_id();
  if (currency_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_id_ = new ::std::string;
  }
  currency_id_->assign(value);
}
inline void TradeDataNym_InternalPB::set_currency_id(const char* value, size_t size) {
  set_has_currency_id();
  if (currency_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_id_ = new ::std::string;
  }
  currency_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_currency_id() {
  set_has_currency_id();
  if (currency_id_ == &::google::protobuf::internal::kEmptyString) {
    currency_id_ = new ::std::string;
  }
  return currency_id_;
}
inline ::std::string* TradeDataNym_InternalPB::release_currency_id() {
  clear_has_currency_id();
  if (currency_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_id_;
    currency_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_currency_id(::std::string* currency_id) {
  if (currency_id_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_id_;
  }
  if (currency_id) {
    set_has_currency_id();
    currency_id_ = currency_id;
  } else {
    clear_has_currency_id();
    currency_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency_paid = 12;
inline bool TradeDataNym_InternalPB::has_currency_paid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TradeDataNym_InternalPB::set_has_currency_paid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TradeDataNym_InternalPB::clear_has_currency_paid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TradeDataNym_InternalPB::clear_currency_paid() {
  if (currency_paid_ != &::google::protobuf::internal::kEmptyString) {
    currency_paid_->clear();
  }
  clear_has_currency_paid();
}
inline const ::std::string& TradeDataNym_InternalPB::currency_paid() const {
  return *currency_paid_;
}
inline void TradeDataNym_InternalPB::set_currency_paid(const ::std::string& value) {
  set_has_currency_paid();
  if (currency_paid_ == &::google::protobuf::internal::kEmptyString) {
    currency_paid_ = new ::std::string;
  }
  currency_paid_->assign(value);
}
inline void TradeDataNym_InternalPB::set_currency_paid(const char* value) {
  set_has_currency_paid();
  if (currency_paid_ == &::google::protobuf::internal::kEmptyString) {
    currency_paid_ = new ::std::string;
  }
  currency_paid_->assign(value);
}
inline void TradeDataNym_InternalPB::set_currency_paid(const char* value, size_t size) {
  set_has_currency_paid();
  if (currency_paid_ == &::google::protobuf::internal::kEmptyString) {
    currency_paid_ = new ::std::string;
  }
  currency_paid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeDataNym_InternalPB::mutable_currency_paid() {
  set_has_currency_paid();
  if (currency_paid_ == &::google::protobuf::internal::kEmptyString) {
    currency_paid_ = new ::std::string;
  }
  return currency_paid_;
}
inline ::std::string* TradeDataNym_InternalPB::release_currency_paid() {
  clear_has_currency_paid();
  if (currency_paid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_paid_;
    currency_paid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeDataNym_InternalPB::set_allocated_currency_paid(::std::string* currency_paid) {
  if (currency_paid_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_paid_;
  }
  if (currency_paid) {
    set_has_currency_paid();
    currency_paid_ = currency_paid;
  } else {
    clear_has_currency_paid();
    currency_paid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TradeListNym_InternalPB

// repeated .OTDB.TradeDataNym_InternalPB trades = 1;
inline int TradeListNym_InternalPB::trades_size() const {
  return trades_.size();
}
inline void TradeListNym_InternalPB::clear_trades() {
  trades_.Clear();
}
inline const ::OTDB::TradeDataNym_InternalPB& TradeListNym_InternalPB::trades(int index) const {
  return trades_.Get(index);
}
inline ::OTDB::TradeDataNym_InternalPB* TradeListNym_InternalPB::mutable_trades(int index) {
  return trades_.Mutable(index);
}
inline ::OTDB::TradeDataNym_InternalPB* TradeListNym_InternalPB::add_trades() {
  return trades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataNym_InternalPB >&
TradeListNym_InternalPB::trades() const {
  return trades_;
}
inline ::google::protobuf::RepeatedPtrField< ::OTDB::TradeDataNym_InternalPB >*
TradeListNym_InternalPB::mutable_trades() {
  return &trades_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OTDB

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Markets_2eproto__INCLUDED
